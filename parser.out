Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> main
Rule 1     main -> block main
Rule 2     main -> block
Rule 3     block -> declaration
Rule 4     block -> function
Rule 5     block -> assignment
Rule 6     block -> callfunction
Rule 7     block -> expressions
Rule 8     block -> if
Rule 9     block -> while
Rule 10    block -> dowhile
Rule 11    block -> for
Rule 12    block -> print
Rule 13    block -> input
Rule 14    block -> printq
Rule 15    block -> prints
Rule 16    block -> return
Rule 17    declaration -> type ids
Rule 18    declaration -> type arrays
Rule 19    type -> INT
Rule 20    type -> FLOAT
Rule 21    ids -> sorm COMMA ids
Rule 22    ids -> sorm
Rule 23    sorm -> moreids
Rule 24    sorm -> subdeclare
Rule 25    moreids -> ID
Rule 26    subdeclare -> assignment
Rule 27    arrays -> arrayorsub COMMA arrays
Rule 28    arrays -> arrayorsub
Rule 29    arrayorsub -> array
Rule 30    arrayorsub -> subdeclarem
Rule 31    array -> ID args
Rule 32    args -> LSQUARED expression RSQUARED args
Rule 33    args -> LSQUARED expression RSQUARED
Rule 34    subdeclarem -> ID args EQUALS arrvalue
Rule 35    arrvalue -> LCURLY value RCURLY
Rule 36    value -> numberorid COMMA value
Rule 37    value -> numberorid
Rule 38    function -> functionaux LCURLY main RCURLY
Rule 39    return -> RETURN
Rule 40    functionaux -> FUNCTION ID PARENS
Rule 41    assignment -> normalassignment
Rule 42    assignment -> plusplus
Rule 43    assignment -> minusminus
Rule 44    normalassignment -> idorarrayid EQUALS expression
Rule 45    idorarrayid -> ID
Rule 46    idorarrayid -> arrayid
Rule 47    plusplus -> ID PLUSPLUS
Rule 48    minusminus -> ID MINUSMINUS
Rule 49    callfunction -> ID PARENS
Rule 50    expression -> expression PLUS term
Rule 51    expression -> expression MINUS term
Rule 52    expression -> expression OR term
Rule 53    expression -> term
Rule 54    term -> term POWER factor
Rule 55    term -> term TIMES factor
Rule 56    term -> term DIVIDE factor
Rule 57    term -> term MOD factor
Rule 58    term -> term AND factor
Rule 59    term -> factor
Rule 60    factor -> numberorid
Rule 61    factor -> LPAREN expression RPAREN
Rule 62    factor -> numberorid GREATER numberorid
Rule 63    factor -> numberorid LESS numberorid
Rule 64    factor -> numberorid GREATEREQ numberorid
Rule 65    factor -> numberorid LESSEQ numberorid
Rule 66    factor -> numberorid EQUALEQ numberorid
Rule 67    factor -> numberorid NOTEQ numberorid
Rule 68    numberorid -> NUMBER
Rule 69    numberorid -> ID
Rule 70    numberorid -> arrayid
Rule 71    arrayid -> ID args
Rule 72    if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
Rule 73    else -> ELSE if_aux2 LCURLY main RCURLY
Rule 74    else -> ELSE if_aux2 block
Rule 75    else -> empty
Rule 76    if_aux1 -> empty
Rule 77    if_aux2 -> empty
Rule 78    while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
Rule 79    while_aux1 -> empty
Rule 80    while_aux2 -> empty
Rule 81    dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
Rule 82    do_aux -> empty
Rule 83    for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
Rule 84    assignordeclare -> assignment
Rule 85    assignordeclare -> declaration
Rule 86    foraux1 -> empty
Rule 87    foraux2 -> empty
Rule 88    print -> PRINT printaux LPAREN expressions RPAREN
Rule 89    prints -> PRINTS printaux LPAREN expressions RPAREN
Rule 90    printaux -> empty
Rule 91    expressions -> stringorexpression COMMA expressions
Rule 92    expressions -> stringorexpression
Rule 93    stringorexpression -> string
Rule 94    stringorexpression -> expression
Rule 95    string -> STRING
Rule 96    input -> INPUT LPAREN input_ids RPAREN
Rule 97    input_ids -> numberorid COMMA input_ids
Rule 98    input_ids -> numberorid
Rule 99    empty -> <empty>
Rule 100   printq -> PRINTQ PARENS

Terminals, with rules where they appear

AND                  : 58
COMMA                : 21 27 36 91 97
DIVIDE               : 56
DO                   : 81
ELSE                 : 73 74
EQUALEQ              : 66
EQUALS               : 34 44
FLOAT                : 20
FOR                  : 83
FUNCTION             : 40
GREATER              : 62
GREATEREQ            : 64
ID                   : 25 31 34 40 45 47 48 49 69 71
IF                   : 72
INPUT                : 96
INT                  : 19
LCURLY               : 35 38 72 73 78 81 83
LESS                 : 63
LESSEQ               : 65
LPAREN               : 61 72 78 81 83 88 89 96
LSQUARED             : 32 33
MINUS                : 51
MINUSMINUS           : 48
MOD                  : 57
NOTEQ                : 67
NUMBER               : 68
OR                   : 52
PARENS               : 40 49 100
PLUS                 : 50
PLUSPLUS             : 47
POWER                : 54
PRINT                : 88
PRINTQ               : 100
PRINTS               : 89
RCURLY               : 35 38 72 73 78 81 83
RETURN               : 39
RPAREN               : 61 72 78 81 83 88 89 96
RSQUARED             : 32 33
SEMIC                : 81 83 83
STRING               : 95
TIMES                : 55
WHILE                : 78 81
error                : 

Nonterminals, with rules where they appear

args                 : 31 32 34 71
array                : 29
arrayid              : 46 70
arrayorsub           : 27 28
arrays               : 18 27
arrvalue             : 34
assignment           : 5 26 83 84
assignordeclare      : 83
block                : 1 2 74
callfunction         : 6
declaration          : 3 85
do_aux               : 81
dowhile              : 10
else                 : 72
empty                : 75 76 77 79 80 82 86 87 90
expression           : 32 33 44 50 51 52 61 72 78 81 83 94
expressions          : 7 88 89 91
factor               : 54 55 56 57 58 59
for                  : 11
foraux1              : 83
foraux2              : 83
function             : 4
functionaux          : 38
idorarrayid          : 44
ids                  : 17 21
if                   : 8
if_aux1              : 72
if_aux2              : 73 74
input                : 13
input_ids            : 96 97
main                 : 1 38 72 73 78 81 83 0
minusminus           : 43
moreids              : 23
normalassignment     : 41
numberorid           : 36 37 60 62 62 63 63 64 64 65 65 66 66 67 67 97 98
plusplus             : 42
print                : 12
printaux             : 88 89
printq               : 14
prints               : 15
return               : 16
sorm                 : 21 22
string               : 93
stringorexpression   : 91 92
subdeclare           : 24
subdeclarem          : 30
term                 : 50 51 52 53 54 55 56 57 58
type                 : 17 18
value                : 35 36
while                : 9
while_aux1           : 78
while_aux2           : 78

Parsing method: LALR

state 0

    (0) S' -> . main
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    main                           shift and go to state 1
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    expression                     shift and go to state 26
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 1

    (0) S' -> main .



state 2

    (1) main -> block . main
    (2) main -> block .
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    $end            reduce using rule 2 (main -> block .)
    RCURLY          reduce using rule 2 (main -> block .)
    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    block                          shift and go to state 2
    main                           shift and go to state 46
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    expression                     shift and go to state 26
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 3

    (3) block -> declaration .

    ID              reduce using rule 3 (block -> declaration .)
    IF              reduce using rule 3 (block -> declaration .)
    WHILE           reduce using rule 3 (block -> declaration .)
    DO              reduce using rule 3 (block -> declaration .)
    FOR             reduce using rule 3 (block -> declaration .)
    PRINT           reduce using rule 3 (block -> declaration .)
    INPUT           reduce using rule 3 (block -> declaration .)
    PRINTQ          reduce using rule 3 (block -> declaration .)
    PRINTS          reduce using rule 3 (block -> declaration .)
    RETURN          reduce using rule 3 (block -> declaration .)
    INT             reduce using rule 3 (block -> declaration .)
    FLOAT           reduce using rule 3 (block -> declaration .)
    FUNCTION        reduce using rule 3 (block -> declaration .)
    STRING          reduce using rule 3 (block -> declaration .)
    LPAREN          reduce using rule 3 (block -> declaration .)
    NUMBER          reduce using rule 3 (block -> declaration .)
    $end            reduce using rule 3 (block -> declaration .)
    RCURLY          reduce using rule 3 (block -> declaration .)


state 4

    (4) block -> function .

    ID              reduce using rule 4 (block -> function .)
    IF              reduce using rule 4 (block -> function .)
    WHILE           reduce using rule 4 (block -> function .)
    DO              reduce using rule 4 (block -> function .)
    FOR             reduce using rule 4 (block -> function .)
    PRINT           reduce using rule 4 (block -> function .)
    INPUT           reduce using rule 4 (block -> function .)
    PRINTQ          reduce using rule 4 (block -> function .)
    PRINTS          reduce using rule 4 (block -> function .)
    RETURN          reduce using rule 4 (block -> function .)
    INT             reduce using rule 4 (block -> function .)
    FLOAT           reduce using rule 4 (block -> function .)
    FUNCTION        reduce using rule 4 (block -> function .)
    STRING          reduce using rule 4 (block -> function .)
    LPAREN          reduce using rule 4 (block -> function .)
    NUMBER          reduce using rule 4 (block -> function .)
    $end            reduce using rule 4 (block -> function .)
    RCURLY          reduce using rule 4 (block -> function .)


state 5

    (5) block -> assignment .

    ID              reduce using rule 5 (block -> assignment .)
    IF              reduce using rule 5 (block -> assignment .)
    WHILE           reduce using rule 5 (block -> assignment .)
    DO              reduce using rule 5 (block -> assignment .)
    FOR             reduce using rule 5 (block -> assignment .)
    PRINT           reduce using rule 5 (block -> assignment .)
    INPUT           reduce using rule 5 (block -> assignment .)
    PRINTQ          reduce using rule 5 (block -> assignment .)
    PRINTS          reduce using rule 5 (block -> assignment .)
    RETURN          reduce using rule 5 (block -> assignment .)
    INT             reduce using rule 5 (block -> assignment .)
    FLOAT           reduce using rule 5 (block -> assignment .)
    FUNCTION        reduce using rule 5 (block -> assignment .)
    STRING          reduce using rule 5 (block -> assignment .)
    LPAREN          reduce using rule 5 (block -> assignment .)
    NUMBER          reduce using rule 5 (block -> assignment .)
    $end            reduce using rule 5 (block -> assignment .)
    RCURLY          reduce using rule 5 (block -> assignment .)


state 6

    (6) block -> callfunction .

    ID              reduce using rule 6 (block -> callfunction .)
    IF              reduce using rule 6 (block -> callfunction .)
    WHILE           reduce using rule 6 (block -> callfunction .)
    DO              reduce using rule 6 (block -> callfunction .)
    FOR             reduce using rule 6 (block -> callfunction .)
    PRINT           reduce using rule 6 (block -> callfunction .)
    INPUT           reduce using rule 6 (block -> callfunction .)
    PRINTQ          reduce using rule 6 (block -> callfunction .)
    PRINTS          reduce using rule 6 (block -> callfunction .)
    RETURN          reduce using rule 6 (block -> callfunction .)
    INT             reduce using rule 6 (block -> callfunction .)
    FLOAT           reduce using rule 6 (block -> callfunction .)
    FUNCTION        reduce using rule 6 (block -> callfunction .)
    STRING          reduce using rule 6 (block -> callfunction .)
    LPAREN          reduce using rule 6 (block -> callfunction .)
    NUMBER          reduce using rule 6 (block -> callfunction .)
    $end            reduce using rule 6 (block -> callfunction .)
    RCURLY          reduce using rule 6 (block -> callfunction .)


state 7

    (7) block -> expressions .

    ID              reduce using rule 7 (block -> expressions .)
    IF              reduce using rule 7 (block -> expressions .)
    WHILE           reduce using rule 7 (block -> expressions .)
    DO              reduce using rule 7 (block -> expressions .)
    FOR             reduce using rule 7 (block -> expressions .)
    PRINT           reduce using rule 7 (block -> expressions .)
    INPUT           reduce using rule 7 (block -> expressions .)
    PRINTQ          reduce using rule 7 (block -> expressions .)
    PRINTS          reduce using rule 7 (block -> expressions .)
    RETURN          reduce using rule 7 (block -> expressions .)
    INT             reduce using rule 7 (block -> expressions .)
    FLOAT           reduce using rule 7 (block -> expressions .)
    FUNCTION        reduce using rule 7 (block -> expressions .)
    STRING          reduce using rule 7 (block -> expressions .)
    LPAREN          reduce using rule 7 (block -> expressions .)
    NUMBER          reduce using rule 7 (block -> expressions .)
    $end            reduce using rule 7 (block -> expressions .)
    RCURLY          reduce using rule 7 (block -> expressions .)


state 8

    (8) block -> if .

    ID              reduce using rule 8 (block -> if .)
    IF              reduce using rule 8 (block -> if .)
    WHILE           reduce using rule 8 (block -> if .)
    DO              reduce using rule 8 (block -> if .)
    FOR             reduce using rule 8 (block -> if .)
    PRINT           reduce using rule 8 (block -> if .)
    INPUT           reduce using rule 8 (block -> if .)
    PRINTQ          reduce using rule 8 (block -> if .)
    PRINTS          reduce using rule 8 (block -> if .)
    RETURN          reduce using rule 8 (block -> if .)
    INT             reduce using rule 8 (block -> if .)
    FLOAT           reduce using rule 8 (block -> if .)
    FUNCTION        reduce using rule 8 (block -> if .)
    STRING          reduce using rule 8 (block -> if .)
    LPAREN          reduce using rule 8 (block -> if .)
    NUMBER          reduce using rule 8 (block -> if .)
    $end            reduce using rule 8 (block -> if .)
    RCURLY          reduce using rule 8 (block -> if .)


state 9

    (9) block -> while .

    ID              reduce using rule 9 (block -> while .)
    IF              reduce using rule 9 (block -> while .)
    WHILE           reduce using rule 9 (block -> while .)
    DO              reduce using rule 9 (block -> while .)
    FOR             reduce using rule 9 (block -> while .)
    PRINT           reduce using rule 9 (block -> while .)
    INPUT           reduce using rule 9 (block -> while .)
    PRINTQ          reduce using rule 9 (block -> while .)
    PRINTS          reduce using rule 9 (block -> while .)
    RETURN          reduce using rule 9 (block -> while .)
    INT             reduce using rule 9 (block -> while .)
    FLOAT           reduce using rule 9 (block -> while .)
    FUNCTION        reduce using rule 9 (block -> while .)
    STRING          reduce using rule 9 (block -> while .)
    LPAREN          reduce using rule 9 (block -> while .)
    NUMBER          reduce using rule 9 (block -> while .)
    $end            reduce using rule 9 (block -> while .)
    RCURLY          reduce using rule 9 (block -> while .)


state 10

    (10) block -> dowhile .

    ID              reduce using rule 10 (block -> dowhile .)
    IF              reduce using rule 10 (block -> dowhile .)
    WHILE           reduce using rule 10 (block -> dowhile .)
    DO              reduce using rule 10 (block -> dowhile .)
    FOR             reduce using rule 10 (block -> dowhile .)
    PRINT           reduce using rule 10 (block -> dowhile .)
    INPUT           reduce using rule 10 (block -> dowhile .)
    PRINTQ          reduce using rule 10 (block -> dowhile .)
    PRINTS          reduce using rule 10 (block -> dowhile .)
    RETURN          reduce using rule 10 (block -> dowhile .)
    INT             reduce using rule 10 (block -> dowhile .)
    FLOAT           reduce using rule 10 (block -> dowhile .)
    FUNCTION        reduce using rule 10 (block -> dowhile .)
    STRING          reduce using rule 10 (block -> dowhile .)
    LPAREN          reduce using rule 10 (block -> dowhile .)
    NUMBER          reduce using rule 10 (block -> dowhile .)
    $end            reduce using rule 10 (block -> dowhile .)
    RCURLY          reduce using rule 10 (block -> dowhile .)


state 11

    (11) block -> for .

    ID              reduce using rule 11 (block -> for .)
    IF              reduce using rule 11 (block -> for .)
    WHILE           reduce using rule 11 (block -> for .)
    DO              reduce using rule 11 (block -> for .)
    FOR             reduce using rule 11 (block -> for .)
    PRINT           reduce using rule 11 (block -> for .)
    INPUT           reduce using rule 11 (block -> for .)
    PRINTQ          reduce using rule 11 (block -> for .)
    PRINTS          reduce using rule 11 (block -> for .)
    RETURN          reduce using rule 11 (block -> for .)
    INT             reduce using rule 11 (block -> for .)
    FLOAT           reduce using rule 11 (block -> for .)
    FUNCTION        reduce using rule 11 (block -> for .)
    STRING          reduce using rule 11 (block -> for .)
    LPAREN          reduce using rule 11 (block -> for .)
    NUMBER          reduce using rule 11 (block -> for .)
    $end            reduce using rule 11 (block -> for .)
    RCURLY          reduce using rule 11 (block -> for .)


state 12

    (12) block -> print .

    ID              reduce using rule 12 (block -> print .)
    IF              reduce using rule 12 (block -> print .)
    WHILE           reduce using rule 12 (block -> print .)
    DO              reduce using rule 12 (block -> print .)
    FOR             reduce using rule 12 (block -> print .)
    PRINT           reduce using rule 12 (block -> print .)
    INPUT           reduce using rule 12 (block -> print .)
    PRINTQ          reduce using rule 12 (block -> print .)
    PRINTS          reduce using rule 12 (block -> print .)
    RETURN          reduce using rule 12 (block -> print .)
    INT             reduce using rule 12 (block -> print .)
    FLOAT           reduce using rule 12 (block -> print .)
    FUNCTION        reduce using rule 12 (block -> print .)
    STRING          reduce using rule 12 (block -> print .)
    LPAREN          reduce using rule 12 (block -> print .)
    NUMBER          reduce using rule 12 (block -> print .)
    $end            reduce using rule 12 (block -> print .)
    RCURLY          reduce using rule 12 (block -> print .)


state 13

    (13) block -> input .

    ID              reduce using rule 13 (block -> input .)
    IF              reduce using rule 13 (block -> input .)
    WHILE           reduce using rule 13 (block -> input .)
    DO              reduce using rule 13 (block -> input .)
    FOR             reduce using rule 13 (block -> input .)
    PRINT           reduce using rule 13 (block -> input .)
    INPUT           reduce using rule 13 (block -> input .)
    PRINTQ          reduce using rule 13 (block -> input .)
    PRINTS          reduce using rule 13 (block -> input .)
    RETURN          reduce using rule 13 (block -> input .)
    INT             reduce using rule 13 (block -> input .)
    FLOAT           reduce using rule 13 (block -> input .)
    FUNCTION        reduce using rule 13 (block -> input .)
    STRING          reduce using rule 13 (block -> input .)
    LPAREN          reduce using rule 13 (block -> input .)
    NUMBER          reduce using rule 13 (block -> input .)
    $end            reduce using rule 13 (block -> input .)
    RCURLY          reduce using rule 13 (block -> input .)


state 14

    (14) block -> printq .

    ID              reduce using rule 14 (block -> printq .)
    IF              reduce using rule 14 (block -> printq .)
    WHILE           reduce using rule 14 (block -> printq .)
    DO              reduce using rule 14 (block -> printq .)
    FOR             reduce using rule 14 (block -> printq .)
    PRINT           reduce using rule 14 (block -> printq .)
    INPUT           reduce using rule 14 (block -> printq .)
    PRINTQ          reduce using rule 14 (block -> printq .)
    PRINTS          reduce using rule 14 (block -> printq .)
    RETURN          reduce using rule 14 (block -> printq .)
    INT             reduce using rule 14 (block -> printq .)
    FLOAT           reduce using rule 14 (block -> printq .)
    FUNCTION        reduce using rule 14 (block -> printq .)
    STRING          reduce using rule 14 (block -> printq .)
    LPAREN          reduce using rule 14 (block -> printq .)
    NUMBER          reduce using rule 14 (block -> printq .)
    $end            reduce using rule 14 (block -> printq .)
    RCURLY          reduce using rule 14 (block -> printq .)


state 15

    (15) block -> prints .

    ID              reduce using rule 15 (block -> prints .)
    IF              reduce using rule 15 (block -> prints .)
    WHILE           reduce using rule 15 (block -> prints .)
    DO              reduce using rule 15 (block -> prints .)
    FOR             reduce using rule 15 (block -> prints .)
    PRINT           reduce using rule 15 (block -> prints .)
    INPUT           reduce using rule 15 (block -> prints .)
    PRINTQ          reduce using rule 15 (block -> prints .)
    PRINTS          reduce using rule 15 (block -> prints .)
    RETURN          reduce using rule 15 (block -> prints .)
    INT             reduce using rule 15 (block -> prints .)
    FLOAT           reduce using rule 15 (block -> prints .)
    FUNCTION        reduce using rule 15 (block -> prints .)
    STRING          reduce using rule 15 (block -> prints .)
    LPAREN          reduce using rule 15 (block -> prints .)
    NUMBER          reduce using rule 15 (block -> prints .)
    $end            reduce using rule 15 (block -> prints .)
    RCURLY          reduce using rule 15 (block -> prints .)


state 16

    (16) block -> return .

    ID              reduce using rule 16 (block -> return .)
    IF              reduce using rule 16 (block -> return .)
    WHILE           reduce using rule 16 (block -> return .)
    DO              reduce using rule 16 (block -> return .)
    FOR             reduce using rule 16 (block -> return .)
    PRINT           reduce using rule 16 (block -> return .)
    INPUT           reduce using rule 16 (block -> return .)
    PRINTQ          reduce using rule 16 (block -> return .)
    PRINTS          reduce using rule 16 (block -> return .)
    RETURN          reduce using rule 16 (block -> return .)
    INT             reduce using rule 16 (block -> return .)
    FLOAT           reduce using rule 16 (block -> return .)
    FUNCTION        reduce using rule 16 (block -> return .)
    STRING          reduce using rule 16 (block -> return .)
    LPAREN          reduce using rule 16 (block -> return .)
    NUMBER          reduce using rule 16 (block -> return .)
    $end            reduce using rule 16 (block -> return .)
    RCURLY          reduce using rule 16 (block -> return .)


state 17

    (17) declaration -> type . ids
    (18) declaration -> type . arrays
    (21) ids -> . sorm COMMA ids
    (22) ids -> . sorm
    (27) arrays -> . arrayorsub COMMA arrays
    (28) arrays -> . arrayorsub
    (23) sorm -> . moreids
    (24) sorm -> . subdeclare
    (29) arrayorsub -> . array
    (30) arrayorsub -> . subdeclarem
    (25) moreids -> . ID
    (26) subdeclare -> . assignment
    (31) array -> . ID args
    (34) subdeclarem -> . ID args EQUALS arrvalue
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (71) arrayid -> . ID args

    ID              shift and go to state 55

    ids                            shift and go to state 47
    arrays                         shift and go to state 48
    sorm                           shift and go to state 49
    arrayorsub                     shift and go to state 50
    moreids                        shift and go to state 51
    subdeclare                     shift and go to state 52
    array                          shift and go to state 53
    subdeclarem                    shift and go to state 54
    assignment                     shift and go to state 56
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    idorarrayid                    shift and go to state 38
    arrayid                        shift and go to state 57

state 18

    (38) function -> functionaux . LCURLY main RCURLY

    LCURLY          shift and go to state 58


state 19

    (41) assignment -> normalassignment .

    ID              reduce using rule 41 (assignment -> normalassignment .)
    IF              reduce using rule 41 (assignment -> normalassignment .)
    WHILE           reduce using rule 41 (assignment -> normalassignment .)
    DO              reduce using rule 41 (assignment -> normalassignment .)
    FOR             reduce using rule 41 (assignment -> normalassignment .)
    PRINT           reduce using rule 41 (assignment -> normalassignment .)
    INPUT           reduce using rule 41 (assignment -> normalassignment .)
    PRINTQ          reduce using rule 41 (assignment -> normalassignment .)
    PRINTS          reduce using rule 41 (assignment -> normalassignment .)
    RETURN          reduce using rule 41 (assignment -> normalassignment .)
    INT             reduce using rule 41 (assignment -> normalassignment .)
    FLOAT           reduce using rule 41 (assignment -> normalassignment .)
    FUNCTION        reduce using rule 41 (assignment -> normalassignment .)
    STRING          reduce using rule 41 (assignment -> normalassignment .)
    LPAREN          reduce using rule 41 (assignment -> normalassignment .)
    NUMBER          reduce using rule 41 (assignment -> normalassignment .)
    $end            reduce using rule 41 (assignment -> normalassignment .)
    RCURLY          reduce using rule 41 (assignment -> normalassignment .)
    COMMA           reduce using rule 41 (assignment -> normalassignment .)
    SEMIC           reduce using rule 41 (assignment -> normalassignment .)
    RPAREN          reduce using rule 41 (assignment -> normalassignment .)


state 20

    (42) assignment -> plusplus .

    ID              reduce using rule 42 (assignment -> plusplus .)
    IF              reduce using rule 42 (assignment -> plusplus .)
    WHILE           reduce using rule 42 (assignment -> plusplus .)
    DO              reduce using rule 42 (assignment -> plusplus .)
    FOR             reduce using rule 42 (assignment -> plusplus .)
    PRINT           reduce using rule 42 (assignment -> plusplus .)
    INPUT           reduce using rule 42 (assignment -> plusplus .)
    PRINTQ          reduce using rule 42 (assignment -> plusplus .)
    PRINTS          reduce using rule 42 (assignment -> plusplus .)
    RETURN          reduce using rule 42 (assignment -> plusplus .)
    INT             reduce using rule 42 (assignment -> plusplus .)
    FLOAT           reduce using rule 42 (assignment -> plusplus .)
    FUNCTION        reduce using rule 42 (assignment -> plusplus .)
    STRING          reduce using rule 42 (assignment -> plusplus .)
    LPAREN          reduce using rule 42 (assignment -> plusplus .)
    NUMBER          reduce using rule 42 (assignment -> plusplus .)
    $end            reduce using rule 42 (assignment -> plusplus .)
    RCURLY          reduce using rule 42 (assignment -> plusplus .)
    COMMA           reduce using rule 42 (assignment -> plusplus .)
    SEMIC           reduce using rule 42 (assignment -> plusplus .)
    RPAREN          reduce using rule 42 (assignment -> plusplus .)


state 21

    (43) assignment -> minusminus .

    ID              reduce using rule 43 (assignment -> minusminus .)
    IF              reduce using rule 43 (assignment -> minusminus .)
    WHILE           reduce using rule 43 (assignment -> minusminus .)
    DO              reduce using rule 43 (assignment -> minusminus .)
    FOR             reduce using rule 43 (assignment -> minusminus .)
    PRINT           reduce using rule 43 (assignment -> minusminus .)
    INPUT           reduce using rule 43 (assignment -> minusminus .)
    PRINTQ          reduce using rule 43 (assignment -> minusminus .)
    PRINTS          reduce using rule 43 (assignment -> minusminus .)
    RETURN          reduce using rule 43 (assignment -> minusminus .)
    INT             reduce using rule 43 (assignment -> minusminus .)
    FLOAT           reduce using rule 43 (assignment -> minusminus .)
    FUNCTION        reduce using rule 43 (assignment -> minusminus .)
    STRING          reduce using rule 43 (assignment -> minusminus .)
    LPAREN          reduce using rule 43 (assignment -> minusminus .)
    NUMBER          reduce using rule 43 (assignment -> minusminus .)
    $end            reduce using rule 43 (assignment -> minusminus .)
    RCURLY          reduce using rule 43 (assignment -> minusminus .)
    COMMA           reduce using rule 43 (assignment -> minusminus .)
    SEMIC           reduce using rule 43 (assignment -> minusminus .)
    RPAREN          reduce using rule 43 (assignment -> minusminus .)


state 22

    (49) callfunction -> ID . PARENS
    (47) plusplus -> ID . PLUSPLUS
    (48) minusminus -> ID . MINUSMINUS
    (45) idorarrayid -> ID .
    (71) arrayid -> ID . args
    (69) numberorid -> ID .
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    PARENS          shift and go to state 59
    PLUSPLUS        shift and go to state 60
    MINUSMINUS      shift and go to state 61
    EQUALS          reduce using rule 45 (idorarrayid -> ID .)
    GREATER         reduce using rule 69 (numberorid -> ID .)
    LESS            reduce using rule 69 (numberorid -> ID .)
    GREATEREQ       reduce using rule 69 (numberorid -> ID .)
    LESSEQ          reduce using rule 69 (numberorid -> ID .)
    EQUALEQ         reduce using rule 69 (numberorid -> ID .)
    NOTEQ           reduce using rule 69 (numberorid -> ID .)
    POWER           reduce using rule 69 (numberorid -> ID .)
    TIMES           reduce using rule 69 (numberorid -> ID .)
    DIVIDE          reduce using rule 69 (numberorid -> ID .)
    MOD             reduce using rule 69 (numberorid -> ID .)
    AND             reduce using rule 69 (numberorid -> ID .)
    PLUS            reduce using rule 69 (numberorid -> ID .)
    MINUS           reduce using rule 69 (numberorid -> ID .)
    OR              reduce using rule 69 (numberorid -> ID .)
    COMMA           reduce using rule 69 (numberorid -> ID .)
    ID              reduce using rule 69 (numberorid -> ID .)
    IF              reduce using rule 69 (numberorid -> ID .)
    WHILE           reduce using rule 69 (numberorid -> ID .)
    DO              reduce using rule 69 (numberorid -> ID .)
    FOR             reduce using rule 69 (numberorid -> ID .)
    PRINT           reduce using rule 69 (numberorid -> ID .)
    INPUT           reduce using rule 69 (numberorid -> ID .)
    PRINTQ          reduce using rule 69 (numberorid -> ID .)
    PRINTS          reduce using rule 69 (numberorid -> ID .)
    RETURN          reduce using rule 69 (numberorid -> ID .)
    INT             reduce using rule 69 (numberorid -> ID .)
    FLOAT           reduce using rule 69 (numberorid -> ID .)
    FUNCTION        reduce using rule 69 (numberorid -> ID .)
    STRING          reduce using rule 69 (numberorid -> ID .)
    LPAREN          reduce using rule 69 (numberorid -> ID .)
    NUMBER          reduce using rule 69 (numberorid -> ID .)
    $end            reduce using rule 69 (numberorid -> ID .)
    RCURLY          reduce using rule 69 (numberorid -> ID .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 62

state 23

    (91) expressions -> stringorexpression . COMMA expressions
    (92) expressions -> stringorexpression .

    COMMA           shift and go to state 64
    ID              reduce using rule 92 (expressions -> stringorexpression .)
    IF              reduce using rule 92 (expressions -> stringorexpression .)
    WHILE           reduce using rule 92 (expressions -> stringorexpression .)
    DO              reduce using rule 92 (expressions -> stringorexpression .)
    FOR             reduce using rule 92 (expressions -> stringorexpression .)
    PRINT           reduce using rule 92 (expressions -> stringorexpression .)
    INPUT           reduce using rule 92 (expressions -> stringorexpression .)
    PRINTQ          reduce using rule 92 (expressions -> stringorexpression .)
    PRINTS          reduce using rule 92 (expressions -> stringorexpression .)
    RETURN          reduce using rule 92 (expressions -> stringorexpression .)
    INT             reduce using rule 92 (expressions -> stringorexpression .)
    FLOAT           reduce using rule 92 (expressions -> stringorexpression .)
    FUNCTION        reduce using rule 92 (expressions -> stringorexpression .)
    STRING          reduce using rule 92 (expressions -> stringorexpression .)
    LPAREN          reduce using rule 92 (expressions -> stringorexpression .)
    NUMBER          reduce using rule 92 (expressions -> stringorexpression .)
    $end            reduce using rule 92 (expressions -> stringorexpression .)
    RCURLY          reduce using rule 92 (expressions -> stringorexpression .)
    RPAREN          reduce using rule 92 (expressions -> stringorexpression .)


state 24

    (72) if -> IF . LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else

    LPAREN          shift and go to state 65


state 25

    (61) factor -> LPAREN . expression RPAREN
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 66
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 26

    (94) stringorexpression -> expression .
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    COMMA           reduce using rule 94 (stringorexpression -> expression .)
    ID              reduce using rule 94 (stringorexpression -> expression .)
    IF              reduce using rule 94 (stringorexpression -> expression .)
    WHILE           reduce using rule 94 (stringorexpression -> expression .)
    DO              reduce using rule 94 (stringorexpression -> expression .)
    FOR             reduce using rule 94 (stringorexpression -> expression .)
    PRINT           reduce using rule 94 (stringorexpression -> expression .)
    INPUT           reduce using rule 94 (stringorexpression -> expression .)
    PRINTQ          reduce using rule 94 (stringorexpression -> expression .)
    PRINTS          reduce using rule 94 (stringorexpression -> expression .)
    RETURN          reduce using rule 94 (stringorexpression -> expression .)
    INT             reduce using rule 94 (stringorexpression -> expression .)
    FLOAT           reduce using rule 94 (stringorexpression -> expression .)
    FUNCTION        reduce using rule 94 (stringorexpression -> expression .)
    STRING          reduce using rule 94 (stringorexpression -> expression .)
    LPAREN          reduce using rule 94 (stringorexpression -> expression .)
    NUMBER          reduce using rule 94 (stringorexpression -> expression .)
    $end            reduce using rule 94 (stringorexpression -> expression .)
    RCURLY          reduce using rule 94 (stringorexpression -> expression .)
    RPAREN          reduce using rule 94 (stringorexpression -> expression .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 27

    (78) while -> WHILE . while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (79) while_aux1 -> . empty
    (99) empty -> .

    LPAREN          reduce using rule 99 (empty -> .)

    while_aux1                     shift and go to state 72
    empty                          shift and go to state 73

state 28

    (81) dowhile -> DO . do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (82) do_aux -> . empty
    (99) empty -> .

    LCURLY          reduce using rule 99 (empty -> .)

    do_aux                         shift and go to state 74
    empty                          shift and go to state 75

state 29

    (83) for -> FOR . LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY

    LPAREN          shift and go to state 76


state 30

    (88) print -> PRINT . printaux LPAREN expressions RPAREN
    (90) printaux -> . empty
    (99) empty -> .

    LPAREN          reduce using rule 99 (empty -> .)

    printaux                       shift and go to state 77
    empty                          shift and go to state 78

state 31

    (96) input -> INPUT . LPAREN input_ids RPAREN

    LPAREN          shift and go to state 79


state 32

    (100) printq -> PRINTQ . PARENS

    PARENS          shift and go to state 80


state 33

    (89) prints -> PRINTS . printaux LPAREN expressions RPAREN
    (90) printaux -> . empty
    (99) empty -> .

    LPAREN          reduce using rule 99 (empty -> .)

    printaux                       shift and go to state 81
    empty                          shift and go to state 78

state 34

    (39) return -> RETURN .

    ID              reduce using rule 39 (return -> RETURN .)
    IF              reduce using rule 39 (return -> RETURN .)
    WHILE           reduce using rule 39 (return -> RETURN .)
    DO              reduce using rule 39 (return -> RETURN .)
    FOR             reduce using rule 39 (return -> RETURN .)
    PRINT           reduce using rule 39 (return -> RETURN .)
    INPUT           reduce using rule 39 (return -> RETURN .)
    PRINTQ          reduce using rule 39 (return -> RETURN .)
    PRINTS          reduce using rule 39 (return -> RETURN .)
    RETURN          reduce using rule 39 (return -> RETURN .)
    INT             reduce using rule 39 (return -> RETURN .)
    FLOAT           reduce using rule 39 (return -> RETURN .)
    FUNCTION        reduce using rule 39 (return -> RETURN .)
    STRING          reduce using rule 39 (return -> RETURN .)
    LPAREN          reduce using rule 39 (return -> RETURN .)
    NUMBER          reduce using rule 39 (return -> RETURN .)
    $end            reduce using rule 39 (return -> RETURN .)
    RCURLY          reduce using rule 39 (return -> RETURN .)


state 35

    (19) type -> INT .

    ID              reduce using rule 19 (type -> INT .)


state 36

    (20) type -> FLOAT .

    ID              reduce using rule 20 (type -> FLOAT .)


state 37

    (40) functionaux -> FUNCTION . ID PARENS

    ID              shift and go to state 82


state 38

    (44) normalassignment -> idorarrayid . EQUALS expression

    EQUALS          shift and go to state 83


state 39

    (93) stringorexpression -> string .

    COMMA           reduce using rule 93 (stringorexpression -> string .)
    ID              reduce using rule 93 (stringorexpression -> string .)
    IF              reduce using rule 93 (stringorexpression -> string .)
    WHILE           reduce using rule 93 (stringorexpression -> string .)
    DO              reduce using rule 93 (stringorexpression -> string .)
    FOR             reduce using rule 93 (stringorexpression -> string .)
    PRINT           reduce using rule 93 (stringorexpression -> string .)
    INPUT           reduce using rule 93 (stringorexpression -> string .)
    PRINTQ          reduce using rule 93 (stringorexpression -> string .)
    PRINTS          reduce using rule 93 (stringorexpression -> string .)
    RETURN          reduce using rule 93 (stringorexpression -> string .)
    INT             reduce using rule 93 (stringorexpression -> string .)
    FLOAT           reduce using rule 93 (stringorexpression -> string .)
    FUNCTION        reduce using rule 93 (stringorexpression -> string .)
    STRING          reduce using rule 93 (stringorexpression -> string .)
    LPAREN          reduce using rule 93 (stringorexpression -> string .)
    NUMBER          reduce using rule 93 (stringorexpression -> string .)
    $end            reduce using rule 93 (stringorexpression -> string .)
    RCURLY          reduce using rule 93 (stringorexpression -> string .)
    RPAREN          reduce using rule 93 (stringorexpression -> string .)


state 40

    (46) idorarrayid -> arrayid .
    (70) numberorid -> arrayid .

    EQUALS          reduce using rule 46 (idorarrayid -> arrayid .)
    GREATER         reduce using rule 70 (numberorid -> arrayid .)
    LESS            reduce using rule 70 (numberorid -> arrayid .)
    GREATEREQ       reduce using rule 70 (numberorid -> arrayid .)
    LESSEQ          reduce using rule 70 (numberorid -> arrayid .)
    EQUALEQ         reduce using rule 70 (numberorid -> arrayid .)
    NOTEQ           reduce using rule 70 (numberorid -> arrayid .)
    POWER           reduce using rule 70 (numberorid -> arrayid .)
    TIMES           reduce using rule 70 (numberorid -> arrayid .)
    DIVIDE          reduce using rule 70 (numberorid -> arrayid .)
    MOD             reduce using rule 70 (numberorid -> arrayid .)
    AND             reduce using rule 70 (numberorid -> arrayid .)
    PLUS            reduce using rule 70 (numberorid -> arrayid .)
    MINUS           reduce using rule 70 (numberorid -> arrayid .)
    OR              reduce using rule 70 (numberorid -> arrayid .)
    COMMA           reduce using rule 70 (numberorid -> arrayid .)
    ID              reduce using rule 70 (numberorid -> arrayid .)
    IF              reduce using rule 70 (numberorid -> arrayid .)
    WHILE           reduce using rule 70 (numberorid -> arrayid .)
    DO              reduce using rule 70 (numberorid -> arrayid .)
    FOR             reduce using rule 70 (numberorid -> arrayid .)
    PRINT           reduce using rule 70 (numberorid -> arrayid .)
    INPUT           reduce using rule 70 (numberorid -> arrayid .)
    PRINTQ          reduce using rule 70 (numberorid -> arrayid .)
    PRINTS          reduce using rule 70 (numberorid -> arrayid .)
    RETURN          reduce using rule 70 (numberorid -> arrayid .)
    INT             reduce using rule 70 (numberorid -> arrayid .)
    FLOAT           reduce using rule 70 (numberorid -> arrayid .)
    FUNCTION        reduce using rule 70 (numberorid -> arrayid .)
    STRING          reduce using rule 70 (numberorid -> arrayid .)
    LPAREN          reduce using rule 70 (numberorid -> arrayid .)
    NUMBER          reduce using rule 70 (numberorid -> arrayid .)
    $end            reduce using rule 70 (numberorid -> arrayid .)
    RCURLY          reduce using rule 70 (numberorid -> arrayid .)


state 41

    (95) string -> STRING .

    COMMA           reduce using rule 95 (string -> STRING .)
    ID              reduce using rule 95 (string -> STRING .)
    IF              reduce using rule 95 (string -> STRING .)
    WHILE           reduce using rule 95 (string -> STRING .)
    DO              reduce using rule 95 (string -> STRING .)
    FOR             reduce using rule 95 (string -> STRING .)
    PRINT           reduce using rule 95 (string -> STRING .)
    INPUT           reduce using rule 95 (string -> STRING .)
    PRINTQ          reduce using rule 95 (string -> STRING .)
    PRINTS          reduce using rule 95 (string -> STRING .)
    RETURN          reduce using rule 95 (string -> STRING .)
    INT             reduce using rule 95 (string -> STRING .)
    FLOAT           reduce using rule 95 (string -> STRING .)
    FUNCTION        reduce using rule 95 (string -> STRING .)
    STRING          reduce using rule 95 (string -> STRING .)
    LPAREN          reduce using rule 95 (string -> STRING .)
    NUMBER          reduce using rule 95 (string -> STRING .)
    $end            reduce using rule 95 (string -> STRING .)
    RCURLY          reduce using rule 95 (string -> STRING .)
    RPAREN          reduce using rule 95 (string -> STRING .)


state 42

    (53) expression -> term .
    (54) term -> term . POWER factor
    (55) term -> term . TIMES factor
    (56) term -> term . DIVIDE factor
    (57) term -> term . MOD factor
    (58) term -> term . AND factor

    PLUS            reduce using rule 53 (expression -> term .)
    MINUS           reduce using rule 53 (expression -> term .)
    OR              reduce using rule 53 (expression -> term .)
    COMMA           reduce using rule 53 (expression -> term .)
    ID              reduce using rule 53 (expression -> term .)
    IF              reduce using rule 53 (expression -> term .)
    WHILE           reduce using rule 53 (expression -> term .)
    DO              reduce using rule 53 (expression -> term .)
    FOR             reduce using rule 53 (expression -> term .)
    PRINT           reduce using rule 53 (expression -> term .)
    INPUT           reduce using rule 53 (expression -> term .)
    PRINTQ          reduce using rule 53 (expression -> term .)
    PRINTS          reduce using rule 53 (expression -> term .)
    RETURN          reduce using rule 53 (expression -> term .)
    INT             reduce using rule 53 (expression -> term .)
    FLOAT           reduce using rule 53 (expression -> term .)
    FUNCTION        reduce using rule 53 (expression -> term .)
    STRING          reduce using rule 53 (expression -> term .)
    LPAREN          reduce using rule 53 (expression -> term .)
    NUMBER          reduce using rule 53 (expression -> term .)
    $end            reduce using rule 53 (expression -> term .)
    RCURLY          reduce using rule 53 (expression -> term .)
    RPAREN          reduce using rule 53 (expression -> term .)
    RSQUARED        reduce using rule 53 (expression -> term .)
    SEMIC           reduce using rule 53 (expression -> term .)
    POWER           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88


state 43

    (59) term -> factor .

    POWER           reduce using rule 59 (term -> factor .)
    TIMES           reduce using rule 59 (term -> factor .)
    DIVIDE          reduce using rule 59 (term -> factor .)
    MOD             reduce using rule 59 (term -> factor .)
    AND             reduce using rule 59 (term -> factor .)
    PLUS            reduce using rule 59 (term -> factor .)
    MINUS           reduce using rule 59 (term -> factor .)
    OR              reduce using rule 59 (term -> factor .)
    COMMA           reduce using rule 59 (term -> factor .)
    ID              reduce using rule 59 (term -> factor .)
    IF              reduce using rule 59 (term -> factor .)
    WHILE           reduce using rule 59 (term -> factor .)
    DO              reduce using rule 59 (term -> factor .)
    FOR             reduce using rule 59 (term -> factor .)
    PRINT           reduce using rule 59 (term -> factor .)
    INPUT           reduce using rule 59 (term -> factor .)
    PRINTQ          reduce using rule 59 (term -> factor .)
    PRINTS          reduce using rule 59 (term -> factor .)
    RETURN          reduce using rule 59 (term -> factor .)
    INT             reduce using rule 59 (term -> factor .)
    FLOAT           reduce using rule 59 (term -> factor .)
    FUNCTION        reduce using rule 59 (term -> factor .)
    STRING          reduce using rule 59 (term -> factor .)
    LPAREN          reduce using rule 59 (term -> factor .)
    NUMBER          reduce using rule 59 (term -> factor .)
    $end            reduce using rule 59 (term -> factor .)
    RCURLY          reduce using rule 59 (term -> factor .)
    RPAREN          reduce using rule 59 (term -> factor .)
    RSQUARED        reduce using rule 59 (term -> factor .)
    SEMIC           reduce using rule 59 (term -> factor .)


state 44

    (60) factor -> numberorid .
    (62) factor -> numberorid . GREATER numberorid
    (63) factor -> numberorid . LESS numberorid
    (64) factor -> numberorid . GREATEREQ numberorid
    (65) factor -> numberorid . LESSEQ numberorid
    (66) factor -> numberorid . EQUALEQ numberorid
    (67) factor -> numberorid . NOTEQ numberorid

    POWER           reduce using rule 60 (factor -> numberorid .)
    TIMES           reduce using rule 60 (factor -> numberorid .)
    DIVIDE          reduce using rule 60 (factor -> numberorid .)
    MOD             reduce using rule 60 (factor -> numberorid .)
    AND             reduce using rule 60 (factor -> numberorid .)
    PLUS            reduce using rule 60 (factor -> numberorid .)
    MINUS           reduce using rule 60 (factor -> numberorid .)
    OR              reduce using rule 60 (factor -> numberorid .)
    COMMA           reduce using rule 60 (factor -> numberorid .)
    ID              reduce using rule 60 (factor -> numberorid .)
    IF              reduce using rule 60 (factor -> numberorid .)
    WHILE           reduce using rule 60 (factor -> numberorid .)
    DO              reduce using rule 60 (factor -> numberorid .)
    FOR             reduce using rule 60 (factor -> numberorid .)
    PRINT           reduce using rule 60 (factor -> numberorid .)
    INPUT           reduce using rule 60 (factor -> numberorid .)
    PRINTQ          reduce using rule 60 (factor -> numberorid .)
    PRINTS          reduce using rule 60 (factor -> numberorid .)
    RETURN          reduce using rule 60 (factor -> numberorid .)
    INT             reduce using rule 60 (factor -> numberorid .)
    FLOAT           reduce using rule 60 (factor -> numberorid .)
    FUNCTION        reduce using rule 60 (factor -> numberorid .)
    STRING          reduce using rule 60 (factor -> numberorid .)
    LPAREN          reduce using rule 60 (factor -> numberorid .)
    NUMBER          reduce using rule 60 (factor -> numberorid .)
    $end            reduce using rule 60 (factor -> numberorid .)
    RCURLY          reduce using rule 60 (factor -> numberorid .)
    RPAREN          reduce using rule 60 (factor -> numberorid .)
    RSQUARED        reduce using rule 60 (factor -> numberorid .)
    SEMIC           reduce using rule 60 (factor -> numberorid .)
    GREATER         shift and go to state 89
    LESS            shift and go to state 90
    GREATEREQ       shift and go to state 91
    LESSEQ          shift and go to state 92
    EQUALEQ         shift and go to state 93
    NOTEQ           shift and go to state 94


state 45

    (68) numberorid -> NUMBER .

    GREATER         reduce using rule 68 (numberorid -> NUMBER .)
    LESS            reduce using rule 68 (numberorid -> NUMBER .)
    GREATEREQ       reduce using rule 68 (numberorid -> NUMBER .)
    LESSEQ          reduce using rule 68 (numberorid -> NUMBER .)
    EQUALEQ         reduce using rule 68 (numberorid -> NUMBER .)
    NOTEQ           reduce using rule 68 (numberorid -> NUMBER .)
    POWER           reduce using rule 68 (numberorid -> NUMBER .)
    TIMES           reduce using rule 68 (numberorid -> NUMBER .)
    DIVIDE          reduce using rule 68 (numberorid -> NUMBER .)
    MOD             reduce using rule 68 (numberorid -> NUMBER .)
    AND             reduce using rule 68 (numberorid -> NUMBER .)
    PLUS            reduce using rule 68 (numberorid -> NUMBER .)
    MINUS           reduce using rule 68 (numberorid -> NUMBER .)
    OR              reduce using rule 68 (numberorid -> NUMBER .)
    COMMA           reduce using rule 68 (numberorid -> NUMBER .)
    ID              reduce using rule 68 (numberorid -> NUMBER .)
    IF              reduce using rule 68 (numberorid -> NUMBER .)
    WHILE           reduce using rule 68 (numberorid -> NUMBER .)
    DO              reduce using rule 68 (numberorid -> NUMBER .)
    FOR             reduce using rule 68 (numberorid -> NUMBER .)
    PRINT           reduce using rule 68 (numberorid -> NUMBER .)
    INPUT           reduce using rule 68 (numberorid -> NUMBER .)
    PRINTQ          reduce using rule 68 (numberorid -> NUMBER .)
    PRINTS          reduce using rule 68 (numberorid -> NUMBER .)
    RETURN          reduce using rule 68 (numberorid -> NUMBER .)
    INT             reduce using rule 68 (numberorid -> NUMBER .)
    FLOAT           reduce using rule 68 (numberorid -> NUMBER .)
    FUNCTION        reduce using rule 68 (numberorid -> NUMBER .)
    STRING          reduce using rule 68 (numberorid -> NUMBER .)
    LPAREN          reduce using rule 68 (numberorid -> NUMBER .)
    NUMBER          reduce using rule 68 (numberorid -> NUMBER .)
    $end            reduce using rule 68 (numberorid -> NUMBER .)
    RCURLY          reduce using rule 68 (numberorid -> NUMBER .)
    RPAREN          reduce using rule 68 (numberorid -> NUMBER .)
    RSQUARED        reduce using rule 68 (numberorid -> NUMBER .)
    SEMIC           reduce using rule 68 (numberorid -> NUMBER .)


state 46

    (1) main -> block main .

    $end            reduce using rule 1 (main -> block main .)
    RCURLY          reduce using rule 1 (main -> block main .)


state 47

    (17) declaration -> type ids .

    ID              reduce using rule 17 (declaration -> type ids .)
    IF              reduce using rule 17 (declaration -> type ids .)
    WHILE           reduce using rule 17 (declaration -> type ids .)
    DO              reduce using rule 17 (declaration -> type ids .)
    FOR             reduce using rule 17 (declaration -> type ids .)
    PRINT           reduce using rule 17 (declaration -> type ids .)
    INPUT           reduce using rule 17 (declaration -> type ids .)
    PRINTQ          reduce using rule 17 (declaration -> type ids .)
    PRINTS          reduce using rule 17 (declaration -> type ids .)
    RETURN          reduce using rule 17 (declaration -> type ids .)
    INT             reduce using rule 17 (declaration -> type ids .)
    FLOAT           reduce using rule 17 (declaration -> type ids .)
    FUNCTION        reduce using rule 17 (declaration -> type ids .)
    STRING          reduce using rule 17 (declaration -> type ids .)
    LPAREN          reduce using rule 17 (declaration -> type ids .)
    NUMBER          reduce using rule 17 (declaration -> type ids .)
    $end            reduce using rule 17 (declaration -> type ids .)
    RCURLY          reduce using rule 17 (declaration -> type ids .)
    SEMIC           reduce using rule 17 (declaration -> type ids .)


state 48

    (18) declaration -> type arrays .

    ID              reduce using rule 18 (declaration -> type arrays .)
    IF              reduce using rule 18 (declaration -> type arrays .)
    WHILE           reduce using rule 18 (declaration -> type arrays .)
    DO              reduce using rule 18 (declaration -> type arrays .)
    FOR             reduce using rule 18 (declaration -> type arrays .)
    PRINT           reduce using rule 18 (declaration -> type arrays .)
    INPUT           reduce using rule 18 (declaration -> type arrays .)
    PRINTQ          reduce using rule 18 (declaration -> type arrays .)
    PRINTS          reduce using rule 18 (declaration -> type arrays .)
    RETURN          reduce using rule 18 (declaration -> type arrays .)
    INT             reduce using rule 18 (declaration -> type arrays .)
    FLOAT           reduce using rule 18 (declaration -> type arrays .)
    FUNCTION        reduce using rule 18 (declaration -> type arrays .)
    STRING          reduce using rule 18 (declaration -> type arrays .)
    LPAREN          reduce using rule 18 (declaration -> type arrays .)
    NUMBER          reduce using rule 18 (declaration -> type arrays .)
    $end            reduce using rule 18 (declaration -> type arrays .)
    RCURLY          reduce using rule 18 (declaration -> type arrays .)
    SEMIC           reduce using rule 18 (declaration -> type arrays .)


state 49

    (21) ids -> sorm . COMMA ids
    (22) ids -> sorm .

    COMMA           shift and go to state 95
    ID              reduce using rule 22 (ids -> sorm .)
    IF              reduce using rule 22 (ids -> sorm .)
    WHILE           reduce using rule 22 (ids -> sorm .)
    DO              reduce using rule 22 (ids -> sorm .)
    FOR             reduce using rule 22 (ids -> sorm .)
    PRINT           reduce using rule 22 (ids -> sorm .)
    INPUT           reduce using rule 22 (ids -> sorm .)
    PRINTQ          reduce using rule 22 (ids -> sorm .)
    PRINTS          reduce using rule 22 (ids -> sorm .)
    RETURN          reduce using rule 22 (ids -> sorm .)
    INT             reduce using rule 22 (ids -> sorm .)
    FLOAT           reduce using rule 22 (ids -> sorm .)
    FUNCTION        reduce using rule 22 (ids -> sorm .)
    STRING          reduce using rule 22 (ids -> sorm .)
    LPAREN          reduce using rule 22 (ids -> sorm .)
    NUMBER          reduce using rule 22 (ids -> sorm .)
    $end            reduce using rule 22 (ids -> sorm .)
    RCURLY          reduce using rule 22 (ids -> sorm .)
    SEMIC           reduce using rule 22 (ids -> sorm .)


state 50

    (27) arrays -> arrayorsub . COMMA arrays
    (28) arrays -> arrayorsub .

    COMMA           shift and go to state 96
    ID              reduce using rule 28 (arrays -> arrayorsub .)
    IF              reduce using rule 28 (arrays -> arrayorsub .)
    WHILE           reduce using rule 28 (arrays -> arrayorsub .)
    DO              reduce using rule 28 (arrays -> arrayorsub .)
    FOR             reduce using rule 28 (arrays -> arrayorsub .)
    PRINT           reduce using rule 28 (arrays -> arrayorsub .)
    INPUT           reduce using rule 28 (arrays -> arrayorsub .)
    PRINTQ          reduce using rule 28 (arrays -> arrayorsub .)
    PRINTS          reduce using rule 28 (arrays -> arrayorsub .)
    RETURN          reduce using rule 28 (arrays -> arrayorsub .)
    INT             reduce using rule 28 (arrays -> arrayorsub .)
    FLOAT           reduce using rule 28 (arrays -> arrayorsub .)
    FUNCTION        reduce using rule 28 (arrays -> arrayorsub .)
    STRING          reduce using rule 28 (arrays -> arrayorsub .)
    LPAREN          reduce using rule 28 (arrays -> arrayorsub .)
    NUMBER          reduce using rule 28 (arrays -> arrayorsub .)
    $end            reduce using rule 28 (arrays -> arrayorsub .)
    RCURLY          reduce using rule 28 (arrays -> arrayorsub .)
    SEMIC           reduce using rule 28 (arrays -> arrayorsub .)


state 51

    (23) sorm -> moreids .

    COMMA           reduce using rule 23 (sorm -> moreids .)
    ID              reduce using rule 23 (sorm -> moreids .)
    IF              reduce using rule 23 (sorm -> moreids .)
    WHILE           reduce using rule 23 (sorm -> moreids .)
    DO              reduce using rule 23 (sorm -> moreids .)
    FOR             reduce using rule 23 (sorm -> moreids .)
    PRINT           reduce using rule 23 (sorm -> moreids .)
    INPUT           reduce using rule 23 (sorm -> moreids .)
    PRINTQ          reduce using rule 23 (sorm -> moreids .)
    PRINTS          reduce using rule 23 (sorm -> moreids .)
    RETURN          reduce using rule 23 (sorm -> moreids .)
    INT             reduce using rule 23 (sorm -> moreids .)
    FLOAT           reduce using rule 23 (sorm -> moreids .)
    FUNCTION        reduce using rule 23 (sorm -> moreids .)
    STRING          reduce using rule 23 (sorm -> moreids .)
    LPAREN          reduce using rule 23 (sorm -> moreids .)
    NUMBER          reduce using rule 23 (sorm -> moreids .)
    $end            reduce using rule 23 (sorm -> moreids .)
    RCURLY          reduce using rule 23 (sorm -> moreids .)
    SEMIC           reduce using rule 23 (sorm -> moreids .)


state 52

    (24) sorm -> subdeclare .

    COMMA           reduce using rule 24 (sorm -> subdeclare .)
    ID              reduce using rule 24 (sorm -> subdeclare .)
    IF              reduce using rule 24 (sorm -> subdeclare .)
    WHILE           reduce using rule 24 (sorm -> subdeclare .)
    DO              reduce using rule 24 (sorm -> subdeclare .)
    FOR             reduce using rule 24 (sorm -> subdeclare .)
    PRINT           reduce using rule 24 (sorm -> subdeclare .)
    INPUT           reduce using rule 24 (sorm -> subdeclare .)
    PRINTQ          reduce using rule 24 (sorm -> subdeclare .)
    PRINTS          reduce using rule 24 (sorm -> subdeclare .)
    RETURN          reduce using rule 24 (sorm -> subdeclare .)
    INT             reduce using rule 24 (sorm -> subdeclare .)
    FLOAT           reduce using rule 24 (sorm -> subdeclare .)
    FUNCTION        reduce using rule 24 (sorm -> subdeclare .)
    STRING          reduce using rule 24 (sorm -> subdeclare .)
    LPAREN          reduce using rule 24 (sorm -> subdeclare .)
    NUMBER          reduce using rule 24 (sorm -> subdeclare .)
    $end            reduce using rule 24 (sorm -> subdeclare .)
    RCURLY          reduce using rule 24 (sorm -> subdeclare .)
    SEMIC           reduce using rule 24 (sorm -> subdeclare .)


state 53

    (29) arrayorsub -> array .

    COMMA           reduce using rule 29 (arrayorsub -> array .)
    ID              reduce using rule 29 (arrayorsub -> array .)
    IF              reduce using rule 29 (arrayorsub -> array .)
    WHILE           reduce using rule 29 (arrayorsub -> array .)
    DO              reduce using rule 29 (arrayorsub -> array .)
    FOR             reduce using rule 29 (arrayorsub -> array .)
    PRINT           reduce using rule 29 (arrayorsub -> array .)
    INPUT           reduce using rule 29 (arrayorsub -> array .)
    PRINTQ          reduce using rule 29 (arrayorsub -> array .)
    PRINTS          reduce using rule 29 (arrayorsub -> array .)
    RETURN          reduce using rule 29 (arrayorsub -> array .)
    INT             reduce using rule 29 (arrayorsub -> array .)
    FLOAT           reduce using rule 29 (arrayorsub -> array .)
    FUNCTION        reduce using rule 29 (arrayorsub -> array .)
    STRING          reduce using rule 29 (arrayorsub -> array .)
    LPAREN          reduce using rule 29 (arrayorsub -> array .)
    NUMBER          reduce using rule 29 (arrayorsub -> array .)
    $end            reduce using rule 29 (arrayorsub -> array .)
    RCURLY          reduce using rule 29 (arrayorsub -> array .)
    SEMIC           reduce using rule 29 (arrayorsub -> array .)


state 54

    (30) arrayorsub -> subdeclarem .

    COMMA           reduce using rule 30 (arrayorsub -> subdeclarem .)
    ID              reduce using rule 30 (arrayorsub -> subdeclarem .)
    IF              reduce using rule 30 (arrayorsub -> subdeclarem .)
    WHILE           reduce using rule 30 (arrayorsub -> subdeclarem .)
    DO              reduce using rule 30 (arrayorsub -> subdeclarem .)
    FOR             reduce using rule 30 (arrayorsub -> subdeclarem .)
    PRINT           reduce using rule 30 (arrayorsub -> subdeclarem .)
    INPUT           reduce using rule 30 (arrayorsub -> subdeclarem .)
    PRINTQ          reduce using rule 30 (arrayorsub -> subdeclarem .)
    PRINTS          reduce using rule 30 (arrayorsub -> subdeclarem .)
    RETURN          reduce using rule 30 (arrayorsub -> subdeclarem .)
    INT             reduce using rule 30 (arrayorsub -> subdeclarem .)
    FLOAT           reduce using rule 30 (arrayorsub -> subdeclarem .)
    FUNCTION        reduce using rule 30 (arrayorsub -> subdeclarem .)
    STRING          reduce using rule 30 (arrayorsub -> subdeclarem .)
    LPAREN          reduce using rule 30 (arrayorsub -> subdeclarem .)
    NUMBER          reduce using rule 30 (arrayorsub -> subdeclarem .)
    $end            reduce using rule 30 (arrayorsub -> subdeclarem .)
    RCURLY          reduce using rule 30 (arrayorsub -> subdeclarem .)
    SEMIC           reduce using rule 30 (arrayorsub -> subdeclarem .)


state 55

    (25) moreids -> ID .
    (31) array -> ID . args
    (34) subdeclarem -> ID . args EQUALS arrvalue
    (47) plusplus -> ID . PLUSPLUS
    (48) minusminus -> ID . MINUSMINUS
    (45) idorarrayid -> ID .
    (71) arrayid -> ID . args
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    COMMA           reduce using rule 25 (moreids -> ID .)
    ID              reduce using rule 25 (moreids -> ID .)
    IF              reduce using rule 25 (moreids -> ID .)
    WHILE           reduce using rule 25 (moreids -> ID .)
    DO              reduce using rule 25 (moreids -> ID .)
    FOR             reduce using rule 25 (moreids -> ID .)
    PRINT           reduce using rule 25 (moreids -> ID .)
    INPUT           reduce using rule 25 (moreids -> ID .)
    PRINTQ          reduce using rule 25 (moreids -> ID .)
    PRINTS          reduce using rule 25 (moreids -> ID .)
    RETURN          reduce using rule 25 (moreids -> ID .)
    INT             reduce using rule 25 (moreids -> ID .)
    FLOAT           reduce using rule 25 (moreids -> ID .)
    FUNCTION        reduce using rule 25 (moreids -> ID .)
    STRING          reduce using rule 25 (moreids -> ID .)
    LPAREN          reduce using rule 25 (moreids -> ID .)
    NUMBER          reduce using rule 25 (moreids -> ID .)
    $end            reduce using rule 25 (moreids -> ID .)
    RCURLY          reduce using rule 25 (moreids -> ID .)
    SEMIC           reduce using rule 25 (moreids -> ID .)
    PLUSPLUS        shift and go to state 60
    MINUSMINUS      shift and go to state 61
    EQUALS          reduce using rule 45 (idorarrayid -> ID .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 97

state 56

    (26) subdeclare -> assignment .

    COMMA           reduce using rule 26 (subdeclare -> assignment .)
    ID              reduce using rule 26 (subdeclare -> assignment .)
    IF              reduce using rule 26 (subdeclare -> assignment .)
    WHILE           reduce using rule 26 (subdeclare -> assignment .)
    DO              reduce using rule 26 (subdeclare -> assignment .)
    FOR             reduce using rule 26 (subdeclare -> assignment .)
    PRINT           reduce using rule 26 (subdeclare -> assignment .)
    INPUT           reduce using rule 26 (subdeclare -> assignment .)
    PRINTQ          reduce using rule 26 (subdeclare -> assignment .)
    PRINTS          reduce using rule 26 (subdeclare -> assignment .)
    RETURN          reduce using rule 26 (subdeclare -> assignment .)
    INT             reduce using rule 26 (subdeclare -> assignment .)
    FLOAT           reduce using rule 26 (subdeclare -> assignment .)
    FUNCTION        reduce using rule 26 (subdeclare -> assignment .)
    STRING          reduce using rule 26 (subdeclare -> assignment .)
    LPAREN          reduce using rule 26 (subdeclare -> assignment .)
    NUMBER          reduce using rule 26 (subdeclare -> assignment .)
    $end            reduce using rule 26 (subdeclare -> assignment .)
    RCURLY          reduce using rule 26 (subdeclare -> assignment .)
    SEMIC           reduce using rule 26 (subdeclare -> assignment .)


state 57

    (46) idorarrayid -> arrayid .

    EQUALS          reduce using rule 46 (idorarrayid -> arrayid .)


state 58

    (38) function -> functionaux LCURLY . main RCURLY
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    functionaux                    shift and go to state 18
    main                           shift and go to state 98
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    expression                     shift and go to state 26
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 59

    (49) callfunction -> ID PARENS .

    ID              reduce using rule 49 (callfunction -> ID PARENS .)
    IF              reduce using rule 49 (callfunction -> ID PARENS .)
    WHILE           reduce using rule 49 (callfunction -> ID PARENS .)
    DO              reduce using rule 49 (callfunction -> ID PARENS .)
    FOR             reduce using rule 49 (callfunction -> ID PARENS .)
    PRINT           reduce using rule 49 (callfunction -> ID PARENS .)
    INPUT           reduce using rule 49 (callfunction -> ID PARENS .)
    PRINTQ          reduce using rule 49 (callfunction -> ID PARENS .)
    PRINTS          reduce using rule 49 (callfunction -> ID PARENS .)
    RETURN          reduce using rule 49 (callfunction -> ID PARENS .)
    INT             reduce using rule 49 (callfunction -> ID PARENS .)
    FLOAT           reduce using rule 49 (callfunction -> ID PARENS .)
    FUNCTION        reduce using rule 49 (callfunction -> ID PARENS .)
    STRING          reduce using rule 49 (callfunction -> ID PARENS .)
    LPAREN          reduce using rule 49 (callfunction -> ID PARENS .)
    NUMBER          reduce using rule 49 (callfunction -> ID PARENS .)
    $end            reduce using rule 49 (callfunction -> ID PARENS .)
    RCURLY          reduce using rule 49 (callfunction -> ID PARENS .)


state 60

    (47) plusplus -> ID PLUSPLUS .

    ID              reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    IF              reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    WHILE           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    DO              reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    FOR             reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    PRINT           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    INPUT           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    PRINTQ          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    PRINTS          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    RETURN          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    INT             reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    FLOAT           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    FUNCTION        reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    STRING          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    LPAREN          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    NUMBER          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    $end            reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    RCURLY          reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    COMMA           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    SEMIC           reduce using rule 47 (plusplus -> ID PLUSPLUS .)
    RPAREN          reduce using rule 47 (plusplus -> ID PLUSPLUS .)


state 61

    (48) minusminus -> ID MINUSMINUS .

    ID              reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    IF              reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    WHILE           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    DO              reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    FOR             reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    PRINT           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    INPUT           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    PRINTQ          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    PRINTS          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    RETURN          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    INT             reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    FLOAT           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    FUNCTION        reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    STRING          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    LPAREN          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    NUMBER          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    $end            reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    RCURLY          reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    COMMA           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    SEMIC           reduce using rule 48 (minusminus -> ID MINUSMINUS .)
    RPAREN          reduce using rule 48 (minusminus -> ID MINUSMINUS .)


state 62

    (71) arrayid -> ID args .

    EQUALS          reduce using rule 71 (arrayid -> ID args .)
    GREATER         reduce using rule 71 (arrayid -> ID args .)
    LESS            reduce using rule 71 (arrayid -> ID args .)
    GREATEREQ       reduce using rule 71 (arrayid -> ID args .)
    LESSEQ          reduce using rule 71 (arrayid -> ID args .)
    EQUALEQ         reduce using rule 71 (arrayid -> ID args .)
    NOTEQ           reduce using rule 71 (arrayid -> ID args .)
    POWER           reduce using rule 71 (arrayid -> ID args .)
    TIMES           reduce using rule 71 (arrayid -> ID args .)
    DIVIDE          reduce using rule 71 (arrayid -> ID args .)
    MOD             reduce using rule 71 (arrayid -> ID args .)
    AND             reduce using rule 71 (arrayid -> ID args .)
    PLUS            reduce using rule 71 (arrayid -> ID args .)
    MINUS           reduce using rule 71 (arrayid -> ID args .)
    OR              reduce using rule 71 (arrayid -> ID args .)
    COMMA           reduce using rule 71 (arrayid -> ID args .)
    ID              reduce using rule 71 (arrayid -> ID args .)
    IF              reduce using rule 71 (arrayid -> ID args .)
    WHILE           reduce using rule 71 (arrayid -> ID args .)
    DO              reduce using rule 71 (arrayid -> ID args .)
    FOR             reduce using rule 71 (arrayid -> ID args .)
    PRINT           reduce using rule 71 (arrayid -> ID args .)
    INPUT           reduce using rule 71 (arrayid -> ID args .)
    PRINTQ          reduce using rule 71 (arrayid -> ID args .)
    PRINTS          reduce using rule 71 (arrayid -> ID args .)
    RETURN          reduce using rule 71 (arrayid -> ID args .)
    INT             reduce using rule 71 (arrayid -> ID args .)
    FLOAT           reduce using rule 71 (arrayid -> ID args .)
    FUNCTION        reduce using rule 71 (arrayid -> ID args .)
    STRING          reduce using rule 71 (arrayid -> ID args .)
    LPAREN          reduce using rule 71 (arrayid -> ID args .)
    NUMBER          reduce using rule 71 (arrayid -> ID args .)
    $end            reduce using rule 71 (arrayid -> ID args .)
    RCURLY          reduce using rule 71 (arrayid -> ID args .)
    RPAREN          reduce using rule 71 (arrayid -> ID args .)
    RSQUARED        reduce using rule 71 (arrayid -> ID args .)
    SEMIC           reduce using rule 71 (arrayid -> ID args .)


state 63

    (32) args -> LSQUARED . expression RSQUARED args
    (33) args -> LSQUARED . expression RSQUARED
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 99
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 64

    (91) expressions -> stringorexpression COMMA . expressions
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    stringorexpression             shift and go to state 23
    expressions                    shift and go to state 100
    string                         shift and go to state 39
    expression                     shift and go to state 26
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 65

    (72) if -> IF LPAREN . expression RPAREN if_aux1 LCURLY main RCURLY else
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 101
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 66

    (61) factor -> LPAREN expression . RPAREN
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    RPAREN          shift and go to state 102
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 67

    (69) numberorid -> ID .
    (71) arrayid -> ID . args
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    GREATER         reduce using rule 69 (numberorid -> ID .)
    LESS            reduce using rule 69 (numberorid -> ID .)
    GREATEREQ       reduce using rule 69 (numberorid -> ID .)
    LESSEQ          reduce using rule 69 (numberorid -> ID .)
    EQUALEQ         reduce using rule 69 (numberorid -> ID .)
    NOTEQ           reduce using rule 69 (numberorid -> ID .)
    POWER           reduce using rule 69 (numberorid -> ID .)
    TIMES           reduce using rule 69 (numberorid -> ID .)
    DIVIDE          reduce using rule 69 (numberorid -> ID .)
    MOD             reduce using rule 69 (numberorid -> ID .)
    AND             reduce using rule 69 (numberorid -> ID .)
    RPAREN          reduce using rule 69 (numberorid -> ID .)
    PLUS            reduce using rule 69 (numberorid -> ID .)
    MINUS           reduce using rule 69 (numberorid -> ID .)
    OR              reduce using rule 69 (numberorid -> ID .)
    RSQUARED        reduce using rule 69 (numberorid -> ID .)
    COMMA           reduce using rule 69 (numberorid -> ID .)
    ID              reduce using rule 69 (numberorid -> ID .)
    IF              reduce using rule 69 (numberorid -> ID .)
    WHILE           reduce using rule 69 (numberorid -> ID .)
    DO              reduce using rule 69 (numberorid -> ID .)
    FOR             reduce using rule 69 (numberorid -> ID .)
    PRINT           reduce using rule 69 (numberorid -> ID .)
    INPUT           reduce using rule 69 (numberorid -> ID .)
    PRINTQ          reduce using rule 69 (numberorid -> ID .)
    PRINTS          reduce using rule 69 (numberorid -> ID .)
    RETURN          reduce using rule 69 (numberorid -> ID .)
    INT             reduce using rule 69 (numberorid -> ID .)
    FLOAT           reduce using rule 69 (numberorid -> ID .)
    FUNCTION        reduce using rule 69 (numberorid -> ID .)
    STRING          reduce using rule 69 (numberorid -> ID .)
    LPAREN          reduce using rule 69 (numberorid -> ID .)
    NUMBER          reduce using rule 69 (numberorid -> ID .)
    $end            reduce using rule 69 (numberorid -> ID .)
    RCURLY          reduce using rule 69 (numberorid -> ID .)
    SEMIC           reduce using rule 69 (numberorid -> ID .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 62

state 68

    (70) numberorid -> arrayid .

    GREATER         reduce using rule 70 (numberorid -> arrayid .)
    LESS            reduce using rule 70 (numberorid -> arrayid .)
    GREATEREQ       reduce using rule 70 (numberorid -> arrayid .)
    LESSEQ          reduce using rule 70 (numberorid -> arrayid .)
    EQUALEQ         reduce using rule 70 (numberorid -> arrayid .)
    NOTEQ           reduce using rule 70 (numberorid -> arrayid .)
    POWER           reduce using rule 70 (numberorid -> arrayid .)
    TIMES           reduce using rule 70 (numberorid -> arrayid .)
    DIVIDE          reduce using rule 70 (numberorid -> arrayid .)
    MOD             reduce using rule 70 (numberorid -> arrayid .)
    AND             reduce using rule 70 (numberorid -> arrayid .)
    RPAREN          reduce using rule 70 (numberorid -> arrayid .)
    PLUS            reduce using rule 70 (numberorid -> arrayid .)
    MINUS           reduce using rule 70 (numberorid -> arrayid .)
    OR              reduce using rule 70 (numberorid -> arrayid .)
    RSQUARED        reduce using rule 70 (numberorid -> arrayid .)
    COMMA           reduce using rule 70 (numberorid -> arrayid .)
    ID              reduce using rule 70 (numberorid -> arrayid .)
    IF              reduce using rule 70 (numberorid -> arrayid .)
    WHILE           reduce using rule 70 (numberorid -> arrayid .)
    DO              reduce using rule 70 (numberorid -> arrayid .)
    FOR             reduce using rule 70 (numberorid -> arrayid .)
    PRINT           reduce using rule 70 (numberorid -> arrayid .)
    INPUT           reduce using rule 70 (numberorid -> arrayid .)
    PRINTQ          reduce using rule 70 (numberorid -> arrayid .)
    PRINTS          reduce using rule 70 (numberorid -> arrayid .)
    RETURN          reduce using rule 70 (numberorid -> arrayid .)
    INT             reduce using rule 70 (numberorid -> arrayid .)
    FLOAT           reduce using rule 70 (numberorid -> arrayid .)
    FUNCTION        reduce using rule 70 (numberorid -> arrayid .)
    STRING          reduce using rule 70 (numberorid -> arrayid .)
    LPAREN          reduce using rule 70 (numberorid -> arrayid .)
    NUMBER          reduce using rule 70 (numberorid -> arrayid .)
    $end            reduce using rule 70 (numberorid -> arrayid .)
    RCURLY          reduce using rule 70 (numberorid -> arrayid .)
    SEMIC           reduce using rule 70 (numberorid -> arrayid .)


state 69

    (50) expression -> expression PLUS . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    term                           shift and go to state 103
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 70

    (51) expression -> expression MINUS . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    term                           shift and go to state 104
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 71

    (52) expression -> expression OR . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    term                           shift and go to state 105
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 72

    (78) while -> WHILE while_aux1 . LPAREN expression RPAREN while_aux2 LCURLY main RCURLY

    LPAREN          shift and go to state 106


state 73

    (79) while_aux1 -> empty .

    LPAREN          reduce using rule 79 (while_aux1 -> empty .)


state 74

    (81) dowhile -> DO do_aux . LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC

    LCURLY          shift and go to state 107


state 75

    (82) do_aux -> empty .

    LCURLY          reduce using rule 82 (do_aux -> empty .)


state 76

    (83) for -> FOR LPAREN . assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (84) assignordeclare -> . assignment
    (85) assignordeclare -> . declaration
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (19) type -> . INT
    (20) type -> . FLOAT
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (71) arrayid -> . ID args

    ID              shift and go to state 111
    INT             shift and go to state 35
    FLOAT           shift and go to state 36

    assignordeclare                shift and go to state 108
    assignment                     shift and go to state 109
    declaration                    shift and go to state 110
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    type                           shift and go to state 17
    idorarrayid                    shift and go to state 38
    arrayid                        shift and go to state 57

state 77

    (88) print -> PRINT printaux . LPAREN expressions RPAREN

    LPAREN          shift and go to state 112


state 78

    (90) printaux -> empty .

    LPAREN          reduce using rule 90 (printaux -> empty .)


state 79

    (96) input -> INPUT LPAREN . input_ids RPAREN
    (97) input_ids -> . numberorid COMMA input_ids
    (98) input_ids -> . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    input_ids                      shift and go to state 113
    numberorid                     shift and go to state 114
    arrayid                        shift and go to state 68

state 80

    (100) printq -> PRINTQ PARENS .

    ID              reduce using rule 100 (printq -> PRINTQ PARENS .)
    IF              reduce using rule 100 (printq -> PRINTQ PARENS .)
    WHILE           reduce using rule 100 (printq -> PRINTQ PARENS .)
    DO              reduce using rule 100 (printq -> PRINTQ PARENS .)
    FOR             reduce using rule 100 (printq -> PRINTQ PARENS .)
    PRINT           reduce using rule 100 (printq -> PRINTQ PARENS .)
    INPUT           reduce using rule 100 (printq -> PRINTQ PARENS .)
    PRINTQ          reduce using rule 100 (printq -> PRINTQ PARENS .)
    PRINTS          reduce using rule 100 (printq -> PRINTQ PARENS .)
    RETURN          reduce using rule 100 (printq -> PRINTQ PARENS .)
    INT             reduce using rule 100 (printq -> PRINTQ PARENS .)
    FLOAT           reduce using rule 100 (printq -> PRINTQ PARENS .)
    FUNCTION        reduce using rule 100 (printq -> PRINTQ PARENS .)
    STRING          reduce using rule 100 (printq -> PRINTQ PARENS .)
    LPAREN          reduce using rule 100 (printq -> PRINTQ PARENS .)
    NUMBER          reduce using rule 100 (printq -> PRINTQ PARENS .)
    $end            reduce using rule 100 (printq -> PRINTQ PARENS .)
    RCURLY          reduce using rule 100 (printq -> PRINTQ PARENS .)


state 81

    (89) prints -> PRINTS printaux . LPAREN expressions RPAREN

    LPAREN          shift and go to state 115


state 82

    (40) functionaux -> FUNCTION ID . PARENS

    PARENS          shift and go to state 116


state 83

    (44) normalassignment -> idorarrayid EQUALS . expression
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 117
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 84

    (54) term -> term POWER . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    factor                         shift and go to state 118
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 85

    (55) term -> term TIMES . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    factor                         shift and go to state 119
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 86

    (56) term -> term DIVIDE . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    factor                         shift and go to state 120
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 87

    (57) term -> term MOD . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    factor                         shift and go to state 121
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 88

    (58) term -> term AND . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    factor                         shift and go to state 122
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 89

    (62) factor -> numberorid GREATER . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 123
    arrayid                        shift and go to state 68

state 90

    (63) factor -> numberorid LESS . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 124
    arrayid                        shift and go to state 68

state 91

    (64) factor -> numberorid GREATEREQ . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 125
    arrayid                        shift and go to state 68

state 92

    (65) factor -> numberorid LESSEQ . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 126
    arrayid                        shift and go to state 68

state 93

    (66) factor -> numberorid EQUALEQ . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 127
    arrayid                        shift and go to state 68

state 94

    (67) factor -> numberorid NOTEQ . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 128
    arrayid                        shift and go to state 68

state 95

    (21) ids -> sorm COMMA . ids
    (21) ids -> . sorm COMMA ids
    (22) ids -> . sorm
    (23) sorm -> . moreids
    (24) sorm -> . subdeclare
    (25) moreids -> . ID
    (26) subdeclare -> . assignment
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (71) arrayid -> . ID args

    ID              shift and go to state 130

    sorm                           shift and go to state 49
    ids                            shift and go to state 129
    moreids                        shift and go to state 51
    subdeclare                     shift and go to state 52
    assignment                     shift and go to state 56
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    idorarrayid                    shift and go to state 38
    arrayid                        shift and go to state 57

state 96

    (27) arrays -> arrayorsub COMMA . arrays
    (27) arrays -> . arrayorsub COMMA arrays
    (28) arrays -> . arrayorsub
    (29) arrayorsub -> . array
    (30) arrayorsub -> . subdeclarem
    (31) array -> . ID args
    (34) subdeclarem -> . ID args EQUALS arrvalue

    ID              shift and go to state 132

    arrayorsub                     shift and go to state 50
    arrays                         shift and go to state 131
    array                          shift and go to state 53
    subdeclarem                    shift and go to state 54

state 97

    (31) array -> ID args .
    (34) subdeclarem -> ID args . EQUALS arrvalue
    (71) arrayid -> ID args .

  ! shift/reduce conflict for EQUALS resolved as shift
    COMMA           reduce using rule 31 (array -> ID args .)
    ID              reduce using rule 31 (array -> ID args .)
    IF              reduce using rule 31 (array -> ID args .)
    WHILE           reduce using rule 31 (array -> ID args .)
    DO              reduce using rule 31 (array -> ID args .)
    FOR             reduce using rule 31 (array -> ID args .)
    PRINT           reduce using rule 31 (array -> ID args .)
    INPUT           reduce using rule 31 (array -> ID args .)
    PRINTQ          reduce using rule 31 (array -> ID args .)
    PRINTS          reduce using rule 31 (array -> ID args .)
    RETURN          reduce using rule 31 (array -> ID args .)
    INT             reduce using rule 31 (array -> ID args .)
    FLOAT           reduce using rule 31 (array -> ID args .)
    FUNCTION        reduce using rule 31 (array -> ID args .)
    STRING          reduce using rule 31 (array -> ID args .)
    LPAREN          reduce using rule 31 (array -> ID args .)
    NUMBER          reduce using rule 31 (array -> ID args .)
    $end            reduce using rule 31 (array -> ID args .)
    RCURLY          reduce using rule 31 (array -> ID args .)
    SEMIC           reduce using rule 31 (array -> ID args .)
    EQUALS          shift and go to state 133

  ! EQUALS          [ reduce using rule 71 (arrayid -> ID args .) ]


state 98

    (38) function -> functionaux LCURLY main . RCURLY

    RCURLY          shift and go to state 134


state 99

    (32) args -> LSQUARED expression . RSQUARED args
    (33) args -> LSQUARED expression . RSQUARED
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    RSQUARED        shift and go to state 135
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 100

    (91) expressions -> stringorexpression COMMA expressions .

    ID              reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    IF              reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    WHILE           reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    DO              reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    FOR             reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    PRINT           reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    INPUT           reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    PRINTQ          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    PRINTS          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    RETURN          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    INT             reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    FLOAT           reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    FUNCTION        reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    STRING          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    LPAREN          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    NUMBER          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    $end            reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    RCURLY          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)
    RPAREN          reduce using rule 91 (expressions -> stringorexpression COMMA expressions .)


state 101

    (72) if -> IF LPAREN expression . RPAREN if_aux1 LCURLY main RCURLY else
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    RPAREN          shift and go to state 136
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 102

    (61) factor -> LPAREN expression RPAREN .

    POWER           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    MOD             reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    PRINTQ          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    PRINTS          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    FUNCTION        reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    STRING          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    RCURLY          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    RSQUARED        reduce using rule 61 (factor -> LPAREN expression RPAREN .)
    SEMIC           reduce using rule 61 (factor -> LPAREN expression RPAREN .)


state 103

    (50) expression -> expression PLUS term .
    (54) term -> term . POWER factor
    (55) term -> term . TIMES factor
    (56) term -> term . DIVIDE factor
    (57) term -> term . MOD factor
    (58) term -> term . AND factor

    PLUS            reduce using rule 50 (expression -> expression PLUS term .)
    MINUS           reduce using rule 50 (expression -> expression PLUS term .)
    OR              reduce using rule 50 (expression -> expression PLUS term .)
    COMMA           reduce using rule 50 (expression -> expression PLUS term .)
    ID              reduce using rule 50 (expression -> expression PLUS term .)
    IF              reduce using rule 50 (expression -> expression PLUS term .)
    WHILE           reduce using rule 50 (expression -> expression PLUS term .)
    DO              reduce using rule 50 (expression -> expression PLUS term .)
    FOR             reduce using rule 50 (expression -> expression PLUS term .)
    PRINT           reduce using rule 50 (expression -> expression PLUS term .)
    INPUT           reduce using rule 50 (expression -> expression PLUS term .)
    PRINTQ          reduce using rule 50 (expression -> expression PLUS term .)
    PRINTS          reduce using rule 50 (expression -> expression PLUS term .)
    RETURN          reduce using rule 50 (expression -> expression PLUS term .)
    INT             reduce using rule 50 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 50 (expression -> expression PLUS term .)
    FUNCTION        reduce using rule 50 (expression -> expression PLUS term .)
    STRING          reduce using rule 50 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 50 (expression -> expression PLUS term .)
    NUMBER          reduce using rule 50 (expression -> expression PLUS term .)
    $end            reduce using rule 50 (expression -> expression PLUS term .)
    RCURLY          reduce using rule 50 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 50 (expression -> expression PLUS term .)
    RSQUARED        reduce using rule 50 (expression -> expression PLUS term .)
    SEMIC           reduce using rule 50 (expression -> expression PLUS term .)
    POWER           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88


state 104

    (51) expression -> expression MINUS term .
    (54) term -> term . POWER factor
    (55) term -> term . TIMES factor
    (56) term -> term . DIVIDE factor
    (57) term -> term . MOD factor
    (58) term -> term . AND factor

    PLUS            reduce using rule 51 (expression -> expression MINUS term .)
    MINUS           reduce using rule 51 (expression -> expression MINUS term .)
    OR              reduce using rule 51 (expression -> expression MINUS term .)
    COMMA           reduce using rule 51 (expression -> expression MINUS term .)
    ID              reduce using rule 51 (expression -> expression MINUS term .)
    IF              reduce using rule 51 (expression -> expression MINUS term .)
    WHILE           reduce using rule 51 (expression -> expression MINUS term .)
    DO              reduce using rule 51 (expression -> expression MINUS term .)
    FOR             reduce using rule 51 (expression -> expression MINUS term .)
    PRINT           reduce using rule 51 (expression -> expression MINUS term .)
    INPUT           reduce using rule 51 (expression -> expression MINUS term .)
    PRINTQ          reduce using rule 51 (expression -> expression MINUS term .)
    PRINTS          reduce using rule 51 (expression -> expression MINUS term .)
    RETURN          reduce using rule 51 (expression -> expression MINUS term .)
    INT             reduce using rule 51 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 51 (expression -> expression MINUS term .)
    FUNCTION        reduce using rule 51 (expression -> expression MINUS term .)
    STRING          reduce using rule 51 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 51 (expression -> expression MINUS term .)
    NUMBER          reduce using rule 51 (expression -> expression MINUS term .)
    $end            reduce using rule 51 (expression -> expression MINUS term .)
    RCURLY          reduce using rule 51 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 51 (expression -> expression MINUS term .)
    RSQUARED        reduce using rule 51 (expression -> expression MINUS term .)
    SEMIC           reduce using rule 51 (expression -> expression MINUS term .)
    POWER           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88


state 105

    (52) expression -> expression OR term .
    (54) term -> term . POWER factor
    (55) term -> term . TIMES factor
    (56) term -> term . DIVIDE factor
    (57) term -> term . MOD factor
    (58) term -> term . AND factor

    PLUS            reduce using rule 52 (expression -> expression OR term .)
    MINUS           reduce using rule 52 (expression -> expression OR term .)
    OR              reduce using rule 52 (expression -> expression OR term .)
    COMMA           reduce using rule 52 (expression -> expression OR term .)
    ID              reduce using rule 52 (expression -> expression OR term .)
    IF              reduce using rule 52 (expression -> expression OR term .)
    WHILE           reduce using rule 52 (expression -> expression OR term .)
    DO              reduce using rule 52 (expression -> expression OR term .)
    FOR             reduce using rule 52 (expression -> expression OR term .)
    PRINT           reduce using rule 52 (expression -> expression OR term .)
    INPUT           reduce using rule 52 (expression -> expression OR term .)
    PRINTQ          reduce using rule 52 (expression -> expression OR term .)
    PRINTS          reduce using rule 52 (expression -> expression OR term .)
    RETURN          reduce using rule 52 (expression -> expression OR term .)
    INT             reduce using rule 52 (expression -> expression OR term .)
    FLOAT           reduce using rule 52 (expression -> expression OR term .)
    FUNCTION        reduce using rule 52 (expression -> expression OR term .)
    STRING          reduce using rule 52 (expression -> expression OR term .)
    LPAREN          reduce using rule 52 (expression -> expression OR term .)
    NUMBER          reduce using rule 52 (expression -> expression OR term .)
    $end            reduce using rule 52 (expression -> expression OR term .)
    RCURLY          reduce using rule 52 (expression -> expression OR term .)
    RPAREN          reduce using rule 52 (expression -> expression OR term .)
    RSQUARED        reduce using rule 52 (expression -> expression OR term .)
    SEMIC           reduce using rule 52 (expression -> expression OR term .)
    POWER           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88


state 106

    (78) while -> WHILE while_aux1 LPAREN . expression RPAREN while_aux2 LCURLY main RCURLY
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 137
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 107

    (81) dowhile -> DO do_aux LCURLY . main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    main                           shift and go to state 138
    expression                     shift and go to state 26
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 108

    (83) for -> FOR LPAREN assignordeclare . SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY

    SEMIC           shift and go to state 139


state 109

    (84) assignordeclare -> assignment .

    SEMIC           reduce using rule 84 (assignordeclare -> assignment .)


state 110

    (85) assignordeclare -> declaration .

    SEMIC           reduce using rule 85 (assignordeclare -> declaration .)


state 111

    (47) plusplus -> ID . PLUSPLUS
    (48) minusminus -> ID . MINUSMINUS
    (45) idorarrayid -> ID .
    (71) arrayid -> ID . args
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    PLUSPLUS        shift and go to state 60
    MINUSMINUS      shift and go to state 61
    EQUALS          reduce using rule 45 (idorarrayid -> ID .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 62

state 112

    (88) print -> PRINT printaux LPAREN . expressions RPAREN
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expressions                    shift and go to state 140
    stringorexpression             shift and go to state 23
    string                         shift and go to state 39
    expression                     shift and go to state 26
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 113

    (96) input -> INPUT LPAREN input_ids . RPAREN

    RPAREN          shift and go to state 141


state 114

    (97) input_ids -> numberorid . COMMA input_ids
    (98) input_ids -> numberorid .

    COMMA           shift and go to state 142
    RPAREN          reduce using rule 98 (input_ids -> numberorid .)


state 115

    (89) prints -> PRINTS printaux LPAREN . expressions RPAREN
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expressions                    shift and go to state 143
    stringorexpression             shift and go to state 23
    string                         shift and go to state 39
    expression                     shift and go to state 26
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 116

    (40) functionaux -> FUNCTION ID PARENS .

    LCURLY          reduce using rule 40 (functionaux -> FUNCTION ID PARENS .)


state 117

    (44) normalassignment -> idorarrayid EQUALS expression .
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    ID              reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    IF              reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    WHILE           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    DO              reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    FOR             reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    PRINT           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    INPUT           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    PRINTQ          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    PRINTS          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    RETURN          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    INT             reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    FLOAT           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    FUNCTION        reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    STRING          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    LPAREN          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    NUMBER          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    $end            reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    RCURLY          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    COMMA           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    SEMIC           reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    RPAREN          reduce using rule 44 (normalassignment -> idorarrayid EQUALS expression .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 118

    (54) term -> term POWER factor .

    POWER           reduce using rule 54 (term -> term POWER factor .)
    TIMES           reduce using rule 54 (term -> term POWER factor .)
    DIVIDE          reduce using rule 54 (term -> term POWER factor .)
    MOD             reduce using rule 54 (term -> term POWER factor .)
    AND             reduce using rule 54 (term -> term POWER factor .)
    PLUS            reduce using rule 54 (term -> term POWER factor .)
    MINUS           reduce using rule 54 (term -> term POWER factor .)
    OR              reduce using rule 54 (term -> term POWER factor .)
    COMMA           reduce using rule 54 (term -> term POWER factor .)
    ID              reduce using rule 54 (term -> term POWER factor .)
    IF              reduce using rule 54 (term -> term POWER factor .)
    WHILE           reduce using rule 54 (term -> term POWER factor .)
    DO              reduce using rule 54 (term -> term POWER factor .)
    FOR             reduce using rule 54 (term -> term POWER factor .)
    PRINT           reduce using rule 54 (term -> term POWER factor .)
    INPUT           reduce using rule 54 (term -> term POWER factor .)
    PRINTQ          reduce using rule 54 (term -> term POWER factor .)
    PRINTS          reduce using rule 54 (term -> term POWER factor .)
    RETURN          reduce using rule 54 (term -> term POWER factor .)
    INT             reduce using rule 54 (term -> term POWER factor .)
    FLOAT           reduce using rule 54 (term -> term POWER factor .)
    FUNCTION        reduce using rule 54 (term -> term POWER factor .)
    STRING          reduce using rule 54 (term -> term POWER factor .)
    LPAREN          reduce using rule 54 (term -> term POWER factor .)
    NUMBER          reduce using rule 54 (term -> term POWER factor .)
    $end            reduce using rule 54 (term -> term POWER factor .)
    RCURLY          reduce using rule 54 (term -> term POWER factor .)
    RPAREN          reduce using rule 54 (term -> term POWER factor .)
    RSQUARED        reduce using rule 54 (term -> term POWER factor .)
    SEMIC           reduce using rule 54 (term -> term POWER factor .)


state 119

    (55) term -> term TIMES factor .

    POWER           reduce using rule 55 (term -> term TIMES factor .)
    TIMES           reduce using rule 55 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 55 (term -> term TIMES factor .)
    MOD             reduce using rule 55 (term -> term TIMES factor .)
    AND             reduce using rule 55 (term -> term TIMES factor .)
    PLUS            reduce using rule 55 (term -> term TIMES factor .)
    MINUS           reduce using rule 55 (term -> term TIMES factor .)
    OR              reduce using rule 55 (term -> term TIMES factor .)
    COMMA           reduce using rule 55 (term -> term TIMES factor .)
    ID              reduce using rule 55 (term -> term TIMES factor .)
    IF              reduce using rule 55 (term -> term TIMES factor .)
    WHILE           reduce using rule 55 (term -> term TIMES factor .)
    DO              reduce using rule 55 (term -> term TIMES factor .)
    FOR             reduce using rule 55 (term -> term TIMES factor .)
    PRINT           reduce using rule 55 (term -> term TIMES factor .)
    INPUT           reduce using rule 55 (term -> term TIMES factor .)
    PRINTQ          reduce using rule 55 (term -> term TIMES factor .)
    PRINTS          reduce using rule 55 (term -> term TIMES factor .)
    RETURN          reduce using rule 55 (term -> term TIMES factor .)
    INT             reduce using rule 55 (term -> term TIMES factor .)
    FLOAT           reduce using rule 55 (term -> term TIMES factor .)
    FUNCTION        reduce using rule 55 (term -> term TIMES factor .)
    STRING          reduce using rule 55 (term -> term TIMES factor .)
    LPAREN          reduce using rule 55 (term -> term TIMES factor .)
    NUMBER          reduce using rule 55 (term -> term TIMES factor .)
    $end            reduce using rule 55 (term -> term TIMES factor .)
    RCURLY          reduce using rule 55 (term -> term TIMES factor .)
    RPAREN          reduce using rule 55 (term -> term TIMES factor .)
    RSQUARED        reduce using rule 55 (term -> term TIMES factor .)
    SEMIC           reduce using rule 55 (term -> term TIMES factor .)


state 120

    (56) term -> term DIVIDE factor .

    POWER           reduce using rule 56 (term -> term DIVIDE factor .)
    TIMES           reduce using rule 56 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 56 (term -> term DIVIDE factor .)
    MOD             reduce using rule 56 (term -> term DIVIDE factor .)
    AND             reduce using rule 56 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 56 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 56 (term -> term DIVIDE factor .)
    OR              reduce using rule 56 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 56 (term -> term DIVIDE factor .)
    ID              reduce using rule 56 (term -> term DIVIDE factor .)
    IF              reduce using rule 56 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 56 (term -> term DIVIDE factor .)
    DO              reduce using rule 56 (term -> term DIVIDE factor .)
    FOR             reduce using rule 56 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 56 (term -> term DIVIDE factor .)
    INPUT           reduce using rule 56 (term -> term DIVIDE factor .)
    PRINTQ          reduce using rule 56 (term -> term DIVIDE factor .)
    PRINTS          reduce using rule 56 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 56 (term -> term DIVIDE factor .)
    INT             reduce using rule 56 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 56 (term -> term DIVIDE factor .)
    FUNCTION        reduce using rule 56 (term -> term DIVIDE factor .)
    STRING          reduce using rule 56 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 56 (term -> term DIVIDE factor .)
    NUMBER          reduce using rule 56 (term -> term DIVIDE factor .)
    $end            reduce using rule 56 (term -> term DIVIDE factor .)
    RCURLY          reduce using rule 56 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 56 (term -> term DIVIDE factor .)
    RSQUARED        reduce using rule 56 (term -> term DIVIDE factor .)
    SEMIC           reduce using rule 56 (term -> term DIVIDE factor .)


state 121

    (57) term -> term MOD factor .

    POWER           reduce using rule 57 (term -> term MOD factor .)
    TIMES           reduce using rule 57 (term -> term MOD factor .)
    DIVIDE          reduce using rule 57 (term -> term MOD factor .)
    MOD             reduce using rule 57 (term -> term MOD factor .)
    AND             reduce using rule 57 (term -> term MOD factor .)
    PLUS            reduce using rule 57 (term -> term MOD factor .)
    MINUS           reduce using rule 57 (term -> term MOD factor .)
    OR              reduce using rule 57 (term -> term MOD factor .)
    COMMA           reduce using rule 57 (term -> term MOD factor .)
    ID              reduce using rule 57 (term -> term MOD factor .)
    IF              reduce using rule 57 (term -> term MOD factor .)
    WHILE           reduce using rule 57 (term -> term MOD factor .)
    DO              reduce using rule 57 (term -> term MOD factor .)
    FOR             reduce using rule 57 (term -> term MOD factor .)
    PRINT           reduce using rule 57 (term -> term MOD factor .)
    INPUT           reduce using rule 57 (term -> term MOD factor .)
    PRINTQ          reduce using rule 57 (term -> term MOD factor .)
    PRINTS          reduce using rule 57 (term -> term MOD factor .)
    RETURN          reduce using rule 57 (term -> term MOD factor .)
    INT             reduce using rule 57 (term -> term MOD factor .)
    FLOAT           reduce using rule 57 (term -> term MOD factor .)
    FUNCTION        reduce using rule 57 (term -> term MOD factor .)
    STRING          reduce using rule 57 (term -> term MOD factor .)
    LPAREN          reduce using rule 57 (term -> term MOD factor .)
    NUMBER          reduce using rule 57 (term -> term MOD factor .)
    $end            reduce using rule 57 (term -> term MOD factor .)
    RCURLY          reduce using rule 57 (term -> term MOD factor .)
    RPAREN          reduce using rule 57 (term -> term MOD factor .)
    RSQUARED        reduce using rule 57 (term -> term MOD factor .)
    SEMIC           reduce using rule 57 (term -> term MOD factor .)


state 122

    (58) term -> term AND factor .

    POWER           reduce using rule 58 (term -> term AND factor .)
    TIMES           reduce using rule 58 (term -> term AND factor .)
    DIVIDE          reduce using rule 58 (term -> term AND factor .)
    MOD             reduce using rule 58 (term -> term AND factor .)
    AND             reduce using rule 58 (term -> term AND factor .)
    PLUS            reduce using rule 58 (term -> term AND factor .)
    MINUS           reduce using rule 58 (term -> term AND factor .)
    OR              reduce using rule 58 (term -> term AND factor .)
    COMMA           reduce using rule 58 (term -> term AND factor .)
    ID              reduce using rule 58 (term -> term AND factor .)
    IF              reduce using rule 58 (term -> term AND factor .)
    WHILE           reduce using rule 58 (term -> term AND factor .)
    DO              reduce using rule 58 (term -> term AND factor .)
    FOR             reduce using rule 58 (term -> term AND factor .)
    PRINT           reduce using rule 58 (term -> term AND factor .)
    INPUT           reduce using rule 58 (term -> term AND factor .)
    PRINTQ          reduce using rule 58 (term -> term AND factor .)
    PRINTS          reduce using rule 58 (term -> term AND factor .)
    RETURN          reduce using rule 58 (term -> term AND factor .)
    INT             reduce using rule 58 (term -> term AND factor .)
    FLOAT           reduce using rule 58 (term -> term AND factor .)
    FUNCTION        reduce using rule 58 (term -> term AND factor .)
    STRING          reduce using rule 58 (term -> term AND factor .)
    LPAREN          reduce using rule 58 (term -> term AND factor .)
    NUMBER          reduce using rule 58 (term -> term AND factor .)
    $end            reduce using rule 58 (term -> term AND factor .)
    RCURLY          reduce using rule 58 (term -> term AND factor .)
    RPAREN          reduce using rule 58 (term -> term AND factor .)
    RSQUARED        reduce using rule 58 (term -> term AND factor .)
    SEMIC           reduce using rule 58 (term -> term AND factor .)


state 123

    (62) factor -> numberorid GREATER numberorid .

    POWER           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    TIMES           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    DIVIDE          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    MOD             reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    AND             reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    PLUS            reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    MINUS           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    OR              reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    COMMA           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    ID              reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    IF              reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    WHILE           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    DO              reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    FOR             reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    PRINT           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    INPUT           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    PRINTQ          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    PRINTS          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    RETURN          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    INT             reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    FLOAT           reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    FUNCTION        reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    STRING          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    LPAREN          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    NUMBER          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    $end            reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    RCURLY          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    RPAREN          reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    RSQUARED        reduce using rule 62 (factor -> numberorid GREATER numberorid .)
    SEMIC           reduce using rule 62 (factor -> numberorid GREATER numberorid .)


state 124

    (63) factor -> numberorid LESS numberorid .

    POWER           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    TIMES           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    DIVIDE          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    MOD             reduce using rule 63 (factor -> numberorid LESS numberorid .)
    AND             reduce using rule 63 (factor -> numberorid LESS numberorid .)
    PLUS            reduce using rule 63 (factor -> numberorid LESS numberorid .)
    MINUS           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    OR              reduce using rule 63 (factor -> numberorid LESS numberorid .)
    COMMA           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    ID              reduce using rule 63 (factor -> numberorid LESS numberorid .)
    IF              reduce using rule 63 (factor -> numberorid LESS numberorid .)
    WHILE           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    DO              reduce using rule 63 (factor -> numberorid LESS numberorid .)
    FOR             reduce using rule 63 (factor -> numberorid LESS numberorid .)
    PRINT           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    INPUT           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    PRINTQ          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    PRINTS          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    RETURN          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    INT             reduce using rule 63 (factor -> numberorid LESS numberorid .)
    FLOAT           reduce using rule 63 (factor -> numberorid LESS numberorid .)
    FUNCTION        reduce using rule 63 (factor -> numberorid LESS numberorid .)
    STRING          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    LPAREN          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    NUMBER          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    $end            reduce using rule 63 (factor -> numberorid LESS numberorid .)
    RCURLY          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    RPAREN          reduce using rule 63 (factor -> numberorid LESS numberorid .)
    RSQUARED        reduce using rule 63 (factor -> numberorid LESS numberorid .)
    SEMIC           reduce using rule 63 (factor -> numberorid LESS numberorid .)


state 125

    (64) factor -> numberorid GREATEREQ numberorid .

    POWER           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    TIMES           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    DIVIDE          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    MOD             reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    AND             reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    PLUS            reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    MINUS           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    OR              reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    COMMA           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    ID              reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    IF              reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    WHILE           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    DO              reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    FOR             reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    PRINT           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    INPUT           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    PRINTQ          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    PRINTS          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    RETURN          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    INT             reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    FLOAT           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    FUNCTION        reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    STRING          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    LPAREN          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    NUMBER          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    $end            reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    RCURLY          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    RPAREN          reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    RSQUARED        reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)
    SEMIC           reduce using rule 64 (factor -> numberorid GREATEREQ numberorid .)


state 126

    (65) factor -> numberorid LESSEQ numberorid .

    POWER           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    TIMES           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    DIVIDE          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    MOD             reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    AND             reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    PLUS            reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    MINUS           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    OR              reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    COMMA           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    ID              reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    IF              reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    WHILE           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    DO              reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    FOR             reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    PRINT           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    INPUT           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    PRINTQ          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    PRINTS          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    RETURN          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    INT             reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    FLOAT           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    FUNCTION        reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    STRING          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    LPAREN          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    NUMBER          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    $end            reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    RCURLY          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    RPAREN          reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    RSQUARED        reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)
    SEMIC           reduce using rule 65 (factor -> numberorid LESSEQ numberorid .)


state 127

    (66) factor -> numberorid EQUALEQ numberorid .

    POWER           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    TIMES           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    DIVIDE          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    MOD             reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    AND             reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    PLUS            reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    MINUS           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    OR              reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    COMMA           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    ID              reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    IF              reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    WHILE           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    DO              reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    FOR             reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    PRINT           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    INPUT           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    PRINTQ          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    PRINTS          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    RETURN          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    INT             reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    FLOAT           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    FUNCTION        reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    STRING          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    LPAREN          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    NUMBER          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    $end            reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    RCURLY          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    RPAREN          reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    RSQUARED        reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)
    SEMIC           reduce using rule 66 (factor -> numberorid EQUALEQ numberorid .)


state 128

    (67) factor -> numberorid NOTEQ numberorid .

    POWER           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    TIMES           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    DIVIDE          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    MOD             reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    AND             reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    PLUS            reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    MINUS           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    OR              reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    COMMA           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    ID              reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    IF              reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    WHILE           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    DO              reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    FOR             reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    PRINT           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    INPUT           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    PRINTQ          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    PRINTS          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    RETURN          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    INT             reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    FLOAT           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    FUNCTION        reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    STRING          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    LPAREN          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    NUMBER          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    $end            reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    RCURLY          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    RPAREN          reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    RSQUARED        reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)
    SEMIC           reduce using rule 67 (factor -> numberorid NOTEQ numberorid .)


state 129

    (21) ids -> sorm COMMA ids .

    ID              reduce using rule 21 (ids -> sorm COMMA ids .)
    IF              reduce using rule 21 (ids -> sorm COMMA ids .)
    WHILE           reduce using rule 21 (ids -> sorm COMMA ids .)
    DO              reduce using rule 21 (ids -> sorm COMMA ids .)
    FOR             reduce using rule 21 (ids -> sorm COMMA ids .)
    PRINT           reduce using rule 21 (ids -> sorm COMMA ids .)
    INPUT           reduce using rule 21 (ids -> sorm COMMA ids .)
    PRINTQ          reduce using rule 21 (ids -> sorm COMMA ids .)
    PRINTS          reduce using rule 21 (ids -> sorm COMMA ids .)
    RETURN          reduce using rule 21 (ids -> sorm COMMA ids .)
    INT             reduce using rule 21 (ids -> sorm COMMA ids .)
    FLOAT           reduce using rule 21 (ids -> sorm COMMA ids .)
    FUNCTION        reduce using rule 21 (ids -> sorm COMMA ids .)
    STRING          reduce using rule 21 (ids -> sorm COMMA ids .)
    LPAREN          reduce using rule 21 (ids -> sorm COMMA ids .)
    NUMBER          reduce using rule 21 (ids -> sorm COMMA ids .)
    $end            reduce using rule 21 (ids -> sorm COMMA ids .)
    RCURLY          reduce using rule 21 (ids -> sorm COMMA ids .)
    SEMIC           reduce using rule 21 (ids -> sorm COMMA ids .)


state 130

    (25) moreids -> ID .
    (47) plusplus -> ID . PLUSPLUS
    (48) minusminus -> ID . MINUSMINUS
    (45) idorarrayid -> ID .
    (71) arrayid -> ID . args
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    COMMA           reduce using rule 25 (moreids -> ID .)
    ID              reduce using rule 25 (moreids -> ID .)
    IF              reduce using rule 25 (moreids -> ID .)
    WHILE           reduce using rule 25 (moreids -> ID .)
    DO              reduce using rule 25 (moreids -> ID .)
    FOR             reduce using rule 25 (moreids -> ID .)
    PRINT           reduce using rule 25 (moreids -> ID .)
    INPUT           reduce using rule 25 (moreids -> ID .)
    PRINTQ          reduce using rule 25 (moreids -> ID .)
    PRINTS          reduce using rule 25 (moreids -> ID .)
    RETURN          reduce using rule 25 (moreids -> ID .)
    INT             reduce using rule 25 (moreids -> ID .)
    FLOAT           reduce using rule 25 (moreids -> ID .)
    FUNCTION        reduce using rule 25 (moreids -> ID .)
    STRING          reduce using rule 25 (moreids -> ID .)
    LPAREN          reduce using rule 25 (moreids -> ID .)
    NUMBER          reduce using rule 25 (moreids -> ID .)
    $end            reduce using rule 25 (moreids -> ID .)
    RCURLY          reduce using rule 25 (moreids -> ID .)
    SEMIC           reduce using rule 25 (moreids -> ID .)
    PLUSPLUS        shift and go to state 60
    MINUSMINUS      shift and go to state 61
    EQUALS          reduce using rule 45 (idorarrayid -> ID .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 62

state 131

    (27) arrays -> arrayorsub COMMA arrays .

    ID              reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    IF              reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    WHILE           reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    DO              reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    FOR             reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    PRINT           reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    INPUT           reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    PRINTQ          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    PRINTS          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    RETURN          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    INT             reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    FLOAT           reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    FUNCTION        reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    STRING          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    LPAREN          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    NUMBER          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    $end            reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    RCURLY          reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)
    SEMIC           reduce using rule 27 (arrays -> arrayorsub COMMA arrays .)


state 132

    (31) array -> ID . args
    (34) subdeclarem -> ID . args EQUALS arrvalue
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    LSQUARED        shift and go to state 63

    args                           shift and go to state 144

state 133

    (34) subdeclarem -> ID args EQUALS . arrvalue
    (35) arrvalue -> . LCURLY value RCURLY

    LCURLY          shift and go to state 146

    arrvalue                       shift and go to state 145

state 134

    (38) function -> functionaux LCURLY main RCURLY .

    ID              reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    IF              reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    WHILE           reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    DO              reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    FOR             reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    PRINT           reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    INPUT           reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    PRINTQ          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    PRINTS          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    RETURN          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    INT             reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    FLOAT           reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    FUNCTION        reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    STRING          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    LPAREN          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    NUMBER          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    $end            reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)
    RCURLY          reduce using rule 38 (function -> functionaux LCURLY main RCURLY .)


state 135

    (32) args -> LSQUARED expression RSQUARED . args
    (33) args -> LSQUARED expression RSQUARED .
    (32) args -> . LSQUARED expression RSQUARED args
    (33) args -> . LSQUARED expression RSQUARED

    EQUALS          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    GREATER         reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    LESS            reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    GREATEREQ       reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    LESSEQ          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    EQUALEQ         reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    NOTEQ           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    POWER           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    TIMES           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    DIVIDE          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    MOD             reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    AND             reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    PLUS            reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    MINUS           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    OR              reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    COMMA           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    ID              reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    IF              reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    WHILE           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    DO              reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    FOR             reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    PRINT           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    INPUT           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    PRINTQ          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    PRINTS          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    RETURN          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    INT             reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    FLOAT           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    FUNCTION        reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    STRING          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    LPAREN          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    NUMBER          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    $end            reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    RCURLY          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    SEMIC           reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    RPAREN          reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    RSQUARED        reduce using rule 33 (args -> LSQUARED expression RSQUARED .)
    LSQUARED        shift and go to state 63

    args                           shift and go to state 147

state 136

    (72) if -> IF LPAREN expression RPAREN . if_aux1 LCURLY main RCURLY else
    (76) if_aux1 -> . empty
    (99) empty -> .

    LCURLY          reduce using rule 99 (empty -> .)

    if_aux1                        shift and go to state 148
    empty                          shift and go to state 149

state 137

    (78) while -> WHILE while_aux1 LPAREN expression . RPAREN while_aux2 LCURLY main RCURLY
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    RPAREN          shift and go to state 150
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 138

    (81) dowhile -> DO do_aux LCURLY main . RCURLY WHILE LPAREN expression RPAREN SEMIC

    RCURLY          shift and go to state 151


state 139

    (83) for -> FOR LPAREN assignordeclare SEMIC . expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 152
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 140

    (88) print -> PRINT printaux LPAREN expressions . RPAREN

    RPAREN          shift and go to state 153


state 141

    (96) input -> INPUT LPAREN input_ids RPAREN .

    ID              reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    IF              reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    WHILE           reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    DO              reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    FOR             reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    PRINT           reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    INPUT           reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    PRINTQ          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    PRINTS          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    RETURN          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    INT             reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    FLOAT           reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    FUNCTION        reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    STRING          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    LPAREN          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    NUMBER          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    $end            reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)
    RCURLY          reduce using rule 96 (input -> INPUT LPAREN input_ids RPAREN .)


state 142

    (97) input_ids -> numberorid COMMA . input_ids
    (97) input_ids -> . numberorid COMMA input_ids
    (98) input_ids -> . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 114
    input_ids                      shift and go to state 154
    arrayid                        shift and go to state 68

state 143

    (89) prints -> PRINTS printaux LPAREN expressions . RPAREN

    RPAREN          shift and go to state 155


state 144

    (31) array -> ID args .
    (34) subdeclarem -> ID args . EQUALS arrvalue

    COMMA           reduce using rule 31 (array -> ID args .)
    ID              reduce using rule 31 (array -> ID args .)
    IF              reduce using rule 31 (array -> ID args .)
    WHILE           reduce using rule 31 (array -> ID args .)
    DO              reduce using rule 31 (array -> ID args .)
    FOR             reduce using rule 31 (array -> ID args .)
    PRINT           reduce using rule 31 (array -> ID args .)
    INPUT           reduce using rule 31 (array -> ID args .)
    PRINTQ          reduce using rule 31 (array -> ID args .)
    PRINTS          reduce using rule 31 (array -> ID args .)
    RETURN          reduce using rule 31 (array -> ID args .)
    INT             reduce using rule 31 (array -> ID args .)
    FLOAT           reduce using rule 31 (array -> ID args .)
    FUNCTION        reduce using rule 31 (array -> ID args .)
    STRING          reduce using rule 31 (array -> ID args .)
    LPAREN          reduce using rule 31 (array -> ID args .)
    NUMBER          reduce using rule 31 (array -> ID args .)
    $end            reduce using rule 31 (array -> ID args .)
    RCURLY          reduce using rule 31 (array -> ID args .)
    SEMIC           reduce using rule 31 (array -> ID args .)
    EQUALS          shift and go to state 133


state 145

    (34) subdeclarem -> ID args EQUALS arrvalue .

    COMMA           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    ID              reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    IF              reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    WHILE           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    DO              reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    FOR             reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    PRINT           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    INPUT           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    PRINTQ          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    PRINTS          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    RETURN          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    INT             reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    FLOAT           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    FUNCTION        reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    STRING          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    LPAREN          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    NUMBER          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    $end            reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    RCURLY          reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)
    SEMIC           reduce using rule 34 (subdeclarem -> ID args EQUALS arrvalue .)


state 146

    (35) arrvalue -> LCURLY . value RCURLY
    (36) value -> . numberorid COMMA value
    (37) value -> . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    value                          shift and go to state 156
    numberorid                     shift and go to state 157
    arrayid                        shift and go to state 68

state 147

    (32) args -> LSQUARED expression RSQUARED args .

    EQUALS          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    GREATER         reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    LESS            reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    GREATEREQ       reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    LESSEQ          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    EQUALEQ         reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    NOTEQ           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    POWER           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    TIMES           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    DIVIDE          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    MOD             reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    AND             reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    PLUS            reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    MINUS           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    OR              reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    COMMA           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    ID              reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    IF              reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    WHILE           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    DO              reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    FOR             reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    PRINT           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    INPUT           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    PRINTQ          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    PRINTS          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    RETURN          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    INT             reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    FLOAT           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    FUNCTION        reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    STRING          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    LPAREN          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    NUMBER          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    $end            reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    RCURLY          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    SEMIC           reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    RPAREN          reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)
    RSQUARED        reduce using rule 32 (args -> LSQUARED expression RSQUARED args .)


state 148

    (72) if -> IF LPAREN expression RPAREN if_aux1 . LCURLY main RCURLY else

    LCURLY          shift and go to state 158


state 149

    (76) if_aux1 -> empty .

    LCURLY          reduce using rule 76 (if_aux1 -> empty .)


state 150

    (78) while -> WHILE while_aux1 LPAREN expression RPAREN . while_aux2 LCURLY main RCURLY
    (80) while_aux2 -> . empty
    (99) empty -> .

    LCURLY          reduce using rule 99 (empty -> .)

    while_aux2                     shift and go to state 159
    empty                          shift and go to state 160

state 151

    (81) dowhile -> DO do_aux LCURLY main RCURLY . WHILE LPAREN expression RPAREN SEMIC

    WHILE           shift and go to state 161


state 152

    (83) for -> FOR LPAREN assignordeclare SEMIC expression . SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    SEMIC           shift and go to state 162
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 153

    (88) print -> PRINT printaux LPAREN expressions RPAREN .

    ID              reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    IF              reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    WHILE           reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    DO              reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    FOR             reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    PRINT           reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    INPUT           reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    PRINTQ          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    PRINTS          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    RETURN          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    INT             reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    FLOAT           reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    FUNCTION        reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    STRING          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    LPAREN          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    NUMBER          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    $end            reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)
    RCURLY          reduce using rule 88 (print -> PRINT printaux LPAREN expressions RPAREN .)


state 154

    (97) input_ids -> numberorid COMMA input_ids .

    RPAREN          reduce using rule 97 (input_ids -> numberorid COMMA input_ids .)


state 155

    (89) prints -> PRINTS printaux LPAREN expressions RPAREN .

    ID              reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    IF              reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    WHILE           reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    DO              reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    FOR             reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    PRINT           reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    INPUT           reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    PRINTQ          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    PRINTS          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    RETURN          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    INT             reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    FLOAT           reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    FUNCTION        reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    STRING          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    LPAREN          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    NUMBER          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    $end            reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)
    RCURLY          reduce using rule 89 (prints -> PRINTS printaux LPAREN expressions RPAREN .)


state 156

    (35) arrvalue -> LCURLY value . RCURLY

    RCURLY          shift and go to state 163


state 157

    (36) value -> numberorid . COMMA value
    (37) value -> numberorid .

    COMMA           shift and go to state 164
    RCURLY          reduce using rule 37 (value -> numberorid .)


state 158

    (72) if -> IF LPAREN expression RPAREN if_aux1 LCURLY . main RCURLY else
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    expression                     shift and go to state 26
    main                           shift and go to state 165
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 159

    (78) while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 . LCURLY main RCURLY

    LCURLY          shift and go to state 166


state 160

    (80) while_aux2 -> empty .

    LCURLY          reduce using rule 80 (while_aux2 -> empty .)


state 161

    (81) dowhile -> DO do_aux LCURLY main RCURLY WHILE . LPAREN expression RPAREN SEMIC

    LPAREN          shift and go to state 167


state 162

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC . foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (86) foraux1 -> . empty
    (99) empty -> .

    ID              reduce using rule 99 (empty -> .)

    foraux1                        shift and go to state 168
    empty                          shift and go to state 169

state 163

    (35) arrvalue -> LCURLY value RCURLY .

    COMMA           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    ID              reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    IF              reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    WHILE           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    DO              reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    FOR             reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    PRINT           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    INPUT           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    PRINTQ          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    PRINTS          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    RETURN          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    INT             reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    FLOAT           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    FUNCTION        reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    STRING          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    LPAREN          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    NUMBER          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    $end            reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    RCURLY          reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)
    SEMIC           reduce using rule 35 (arrvalue -> LCURLY value RCURLY .)


state 164

    (36) value -> numberorid COMMA . value
    (36) value -> . numberorid COMMA value
    (37) value -> . numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    numberorid                     shift and go to state 157
    value                          shift and go to state 170
    arrayid                        shift and go to state 68

state 165

    (72) if -> IF LPAREN expression RPAREN if_aux1 LCURLY main . RCURLY else

    RCURLY          shift and go to state 171


state 166

    (78) while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY . main RCURLY
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    expression                     shift and go to state 26
    main                           shift and go to state 172
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 167

    (81) dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN . expression RPAREN SEMIC
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid
    (71) arrayid -> . ID args

    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45
    ID              shift and go to state 67

    expression                     shift and go to state 173
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44
    arrayid                        shift and go to state 68

state 168

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 . assignment foraux2 RPAREN LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (71) arrayid -> . ID args

    ID              shift and go to state 111

    assignment                     shift and go to state 174
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    idorarrayid                    shift and go to state 38
    arrayid                        shift and go to state 57

state 169

    (86) foraux1 -> empty .

    ID              reduce using rule 86 (foraux1 -> empty .)


state 170

    (36) value -> numberorid COMMA value .

    RCURLY          reduce using rule 36 (value -> numberorid COMMA value .)


state 171

    (72) if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY . else
    (73) else -> . ELSE if_aux2 LCURLY main RCURLY
    (74) else -> . ELSE if_aux2 block
    (75) else -> . empty
    (99) empty -> .

    ELSE            shift and go to state 176
    ID              reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    DO              reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    INPUT           reduce using rule 99 (empty -> .)
    PRINTQ          reduce using rule 99 (empty -> .)
    PRINTS          reduce using rule 99 (empty -> .)
    RETURN          reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    FUNCTION        reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    LPAREN          reduce using rule 99 (empty -> .)
    NUMBER          reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)
    RCURLY          reduce using rule 99 (empty -> .)

    else                           shift and go to state 175
    empty                          shift and go to state 177

state 172

    (78) while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main . RCURLY

    RCURLY          shift and go to state 178


state 173

    (81) dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression . RPAREN SEMIC
    (50) expression -> expression . PLUS term
    (51) expression -> expression . MINUS term
    (52) expression -> expression . OR term

    RPAREN          shift and go to state 179
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    OR              shift and go to state 71


state 174

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment . foraux2 RPAREN LCURLY main RCURLY
    (87) foraux2 -> . empty
    (99) empty -> .

    RPAREN          reduce using rule 99 (empty -> .)

    foraux2                        shift and go to state 180
    empty                          shift and go to state 181

state 175

    (72) if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .

    ID              reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    IF              reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    WHILE           reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    DO              reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    FOR             reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    PRINT           reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    INPUT           reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    PRINTQ          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    PRINTS          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    RETURN          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    INT             reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    FLOAT           reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    FUNCTION        reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    STRING          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    LPAREN          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    NUMBER          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    $end            reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)
    RCURLY          reduce using rule 72 (if -> IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else .)


state 176

    (73) else -> ELSE . if_aux2 LCURLY main RCURLY
    (74) else -> ELSE . if_aux2 block
    (77) if_aux2 -> . empty
    (99) empty -> .

    LCURLY          reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    DO              reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    INPUT           reduce using rule 99 (empty -> .)
    PRINTQ          reduce using rule 99 (empty -> .)
    PRINTS          reduce using rule 99 (empty -> .)
    RETURN          reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    FUNCTION        reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    LPAREN          reduce using rule 99 (empty -> .)
    NUMBER          reduce using rule 99 (empty -> .)

    if_aux2                        shift and go to state 182
    empty                          shift and go to state 183

state 177

    (75) else -> empty .

    ID              reduce using rule 75 (else -> empty .)
    IF              reduce using rule 75 (else -> empty .)
    WHILE           reduce using rule 75 (else -> empty .)
    DO              reduce using rule 75 (else -> empty .)
    FOR             reduce using rule 75 (else -> empty .)
    PRINT           reduce using rule 75 (else -> empty .)
    INPUT           reduce using rule 75 (else -> empty .)
    PRINTQ          reduce using rule 75 (else -> empty .)
    PRINTS          reduce using rule 75 (else -> empty .)
    RETURN          reduce using rule 75 (else -> empty .)
    INT             reduce using rule 75 (else -> empty .)
    FLOAT           reduce using rule 75 (else -> empty .)
    FUNCTION        reduce using rule 75 (else -> empty .)
    STRING          reduce using rule 75 (else -> empty .)
    LPAREN          reduce using rule 75 (else -> empty .)
    NUMBER          reduce using rule 75 (else -> empty .)
    $end            reduce using rule 75 (else -> empty .)
    RCURLY          reduce using rule 75 (else -> empty .)


state 178

    (78) while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .

    ID              reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    IF              reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    WHILE           reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    DO              reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    FOR             reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    PRINT           reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    INPUT           reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    PRINTQ          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    PRINTS          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    RETURN          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    INT             reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    FLOAT           reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    FUNCTION        reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    STRING          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    LPAREN          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    NUMBER          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    $end            reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)
    RCURLY          reduce using rule 78 (while -> WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY .)


state 179

    (81) dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN . SEMIC

    SEMIC           shift and go to state 184


state 180

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 . RPAREN LCURLY main RCURLY

    RPAREN          shift and go to state 185


state 181

    (87) foraux2 -> empty .

    RPAREN          reduce using rule 87 (foraux2 -> empty .)


state 182

    (73) else -> ELSE if_aux2 . LCURLY main RCURLY
    (74) else -> ELSE if_aux2 . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    LCURLY          shift and go to state 186
    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    block                          shift and go to state 187
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    expression                     shift and go to state 26
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 183

    (77) if_aux2 -> empty .

    LCURLY          reduce using rule 77 (if_aux2 -> empty .)
    ID              reduce using rule 77 (if_aux2 -> empty .)
    IF              reduce using rule 77 (if_aux2 -> empty .)
    WHILE           reduce using rule 77 (if_aux2 -> empty .)
    DO              reduce using rule 77 (if_aux2 -> empty .)
    FOR             reduce using rule 77 (if_aux2 -> empty .)
    PRINT           reduce using rule 77 (if_aux2 -> empty .)
    INPUT           reduce using rule 77 (if_aux2 -> empty .)
    PRINTQ          reduce using rule 77 (if_aux2 -> empty .)
    PRINTS          reduce using rule 77 (if_aux2 -> empty .)
    RETURN          reduce using rule 77 (if_aux2 -> empty .)
    INT             reduce using rule 77 (if_aux2 -> empty .)
    FLOAT           reduce using rule 77 (if_aux2 -> empty .)
    FUNCTION        reduce using rule 77 (if_aux2 -> empty .)
    STRING          reduce using rule 77 (if_aux2 -> empty .)
    LPAREN          reduce using rule 77 (if_aux2 -> empty .)
    NUMBER          reduce using rule 77 (if_aux2 -> empty .)


state 184

    (81) dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .

    ID              reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    IF              reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    WHILE           reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    DO              reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    FOR             reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    PRINT           reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    INPUT           reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    PRINTQ          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    PRINTS          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    RETURN          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    INT             reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    FLOAT           reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    FUNCTION        reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    STRING          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    LPAREN          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    NUMBER          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    $end            reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)
    RCURLY          reduce using rule 81 (dowhile -> DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC .)


state 185

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN . LCURLY main RCURLY

    LCURLY          shift and go to state 188


state 186

    (73) else -> ELSE if_aux2 LCURLY . main RCURLY
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    main                           shift and go to state 189
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    assignment                     shift and go to state 5
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    expression                     shift and go to state 26
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 187

    (74) else -> ELSE if_aux2 block .

    ID              reduce using rule 74 (else -> ELSE if_aux2 block .)
    IF              reduce using rule 74 (else -> ELSE if_aux2 block .)
    WHILE           reduce using rule 74 (else -> ELSE if_aux2 block .)
    DO              reduce using rule 74 (else -> ELSE if_aux2 block .)
    FOR             reduce using rule 74 (else -> ELSE if_aux2 block .)
    PRINT           reduce using rule 74 (else -> ELSE if_aux2 block .)
    INPUT           reduce using rule 74 (else -> ELSE if_aux2 block .)
    PRINTQ          reduce using rule 74 (else -> ELSE if_aux2 block .)
    PRINTS          reduce using rule 74 (else -> ELSE if_aux2 block .)
    RETURN          reduce using rule 74 (else -> ELSE if_aux2 block .)
    INT             reduce using rule 74 (else -> ELSE if_aux2 block .)
    FLOAT           reduce using rule 74 (else -> ELSE if_aux2 block .)
    FUNCTION        reduce using rule 74 (else -> ELSE if_aux2 block .)
    STRING          reduce using rule 74 (else -> ELSE if_aux2 block .)
    LPAREN          reduce using rule 74 (else -> ELSE if_aux2 block .)
    NUMBER          reduce using rule 74 (else -> ELSE if_aux2 block .)
    $end            reduce using rule 74 (else -> ELSE if_aux2 block .)
    RCURLY          reduce using rule 74 (else -> ELSE if_aux2 block .)


state 188

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY . main RCURLY
    (1) main -> . block main
    (2) main -> . block
    (3) block -> . declaration
    (4) block -> . function
    (5) block -> . assignment
    (6) block -> . callfunction
    (7) block -> . expressions
    (8) block -> . if
    (9) block -> . while
    (10) block -> . dowhile
    (11) block -> . for
    (12) block -> . print
    (13) block -> . input
    (14) block -> . printq
    (15) block -> . prints
    (16) block -> . return
    (17) declaration -> . type ids
    (18) declaration -> . type arrays
    (38) function -> . functionaux LCURLY main RCURLY
    (41) assignment -> . normalassignment
    (42) assignment -> . plusplus
    (43) assignment -> . minusminus
    (49) callfunction -> . ID PARENS
    (91) expressions -> . stringorexpression COMMA expressions
    (92) expressions -> . stringorexpression
    (72) if -> . IF LPAREN expression RPAREN if_aux1 LCURLY main RCURLY else
    (78) while -> . WHILE while_aux1 LPAREN expression RPAREN while_aux2 LCURLY main RCURLY
    (81) dowhile -> . DO do_aux LCURLY main RCURLY WHILE LPAREN expression RPAREN SEMIC
    (83) for -> . FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY
    (88) print -> . PRINT printaux LPAREN expressions RPAREN
    (96) input -> . INPUT LPAREN input_ids RPAREN
    (100) printq -> . PRINTQ PARENS
    (89) prints -> . PRINTS printaux LPAREN expressions RPAREN
    (39) return -> . RETURN
    (19) type -> . INT
    (20) type -> . FLOAT
    (40) functionaux -> . FUNCTION ID PARENS
    (44) normalassignment -> . idorarrayid EQUALS expression
    (47) plusplus -> . ID PLUSPLUS
    (48) minusminus -> . ID MINUSMINUS
    (93) stringorexpression -> . string
    (94) stringorexpression -> . expression
    (45) idorarrayid -> . ID
    (46) idorarrayid -> . arrayid
    (95) string -> . STRING
    (50) expression -> . expression PLUS term
    (51) expression -> . expression MINUS term
    (52) expression -> . expression OR term
    (53) expression -> . term
    (71) arrayid -> . ID args
    (54) term -> . term POWER factor
    (55) term -> . term TIMES factor
    (56) term -> . term DIVIDE factor
    (57) term -> . term MOD factor
    (58) term -> . term AND factor
    (59) term -> . factor
    (60) factor -> . numberorid
    (61) factor -> . LPAREN expression RPAREN
    (62) factor -> . numberorid GREATER numberorid
    (63) factor -> . numberorid LESS numberorid
    (64) factor -> . numberorid GREATEREQ numberorid
    (65) factor -> . numberorid LESSEQ numberorid
    (66) factor -> . numberorid EQUALEQ numberorid
    (67) factor -> . numberorid NOTEQ numberorid
    (68) numberorid -> . NUMBER
    (69) numberorid -> . ID
    (70) numberorid -> . arrayid

    ID              shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 27
    DO              shift and go to state 28
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    PRINTQ          shift and go to state 32
    PRINTS          shift and go to state 33
    RETURN          shift and go to state 34
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    FUNCTION        shift and go to state 37
    STRING          shift and go to state 41
    LPAREN          shift and go to state 25
    NUMBER          shift and go to state 45

    expression                     shift and go to state 26
    assignment                     shift and go to state 5
    main                           shift and go to state 190
    block                          shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    callfunction                   shift and go to state 6
    expressions                    shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    dowhile                        shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    printq                         shift and go to state 14
    prints                         shift and go to state 15
    return                         shift and go to state 16
    type                           shift and go to state 17
    functionaux                    shift and go to state 18
    normalassignment               shift and go to state 19
    plusplus                       shift and go to state 20
    minusminus                     shift and go to state 21
    stringorexpression             shift and go to state 23
    idorarrayid                    shift and go to state 38
    string                         shift and go to state 39
    arrayid                        shift and go to state 40
    term                           shift and go to state 42
    factor                         shift and go to state 43
    numberorid                     shift and go to state 44

state 189

    (73) else -> ELSE if_aux2 LCURLY main . RCURLY

    RCURLY          shift and go to state 191


state 190

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main . RCURLY

    RCURLY          shift and go to state 192


state 191

    (73) else -> ELSE if_aux2 LCURLY main RCURLY .

    ID              reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    IF              reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    WHILE           reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    DO              reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    FOR             reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    PRINT           reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    INPUT           reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    PRINTQ          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    PRINTS          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    RETURN          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    INT             reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    FLOAT           reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    FUNCTION        reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    STRING          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    LPAREN          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    NUMBER          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    $end            reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)
    RCURLY          reduce using rule 73 (else -> ELSE if_aux2 LCURLY main RCURLY .)


state 192

    (83) for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .

    ID              reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    IF              reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    WHILE           reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    DO              reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    FOR             reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    PRINT           reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    INPUT           reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    PRINTQ          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    PRINTS          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    RETURN          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    INT             reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    FLOAT           reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    FUNCTION        reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    STRING          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    LPAREN          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    NUMBER          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    $end            reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)
    RCURLY          reduce using rule 83 (for -> FOR LPAREN assignordeclare SEMIC expression SEMIC foraux1 assignment foraux2 RPAREN LCURLY main RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUALS in state 97 resolved as shift
